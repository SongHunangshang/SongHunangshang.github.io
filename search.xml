<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>力扣练习</title>
      <link href="/2023/01/05/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2023/01/05/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="力扣Day1"><a href="#力扣Day1" class="headerlink" title="力扣Day1"></a>力扣Day1</h1><h2 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></h2><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><p>第一种题解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeetCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">int</span>[] nums1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] nums2=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        System.out.println(solution.findMedianSortedArrays(nums1,nums2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> (m + n + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, left) + findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, right)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//i: nums1的起始位置 j: nums2的起始位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKth</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> i, <span class="type">int</span>[] nums2, <span class="type">int</span> j, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( i &gt;= nums1.length) <span class="keyword">return</span> nums2[j + k - <span class="number">1</span>];<span class="comment">//nums1为空数组</span></span><br><span class="line">        <span class="keyword">if</span>( j &gt;= nums2.length) <span class="keyword">return</span> nums1[i + k - <span class="number">1</span>];<span class="comment">//nums2为空数组</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(nums1[i], nums2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal1</span> <span class="operator">=</span> (i + k / <span class="number">2</span> - <span class="number">1</span> &lt; nums1.length) ? nums1[i + k / <span class="number">2</span> - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal2</span> <span class="operator">=</span> (j + k / <span class="number">2</span> - <span class="number">1</span> &lt; nums2.length) ? nums2[j + k / <span class="number">2</span> - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(midVal1 &lt; midVal2)&#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, i + k / <span class="number">2</span>, nums2, j , k - k / <span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, i, nums2, j + k / <span class="number">2</span> , k - k / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p>这道题，我一开始想不通的地方在于，如何在O(n)复杂度中，找出解来，下面的解法是答案中的一种。</p><p>这种解法的核心要点在于，每一次判断sum是否需要叠加的时候，都是先判断和是否大于0，后者再进行一次大小判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">                sum += num;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sum = num;</span><br><span class="line">            res = Math.max(res, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是力扣的讲解，个人觉得比较重要，故拿来记录：</p><p>力扣」第 53 题（最大子序和）是「力扣」第 124 题（二叉树的最大路径和）的线性版本，它们的状态设计思想和状态转移是类似的，希望大家能够通过本题题解进一步体会状态是如何想到的（即子问题的定义需要从哪些方面考虑）。</p><p>本题接的重点在「关键 1：理解题意」和「关键 2：如何定义子问题（如何定义状态）」和「最后再谈谈「无后效性」。</p><p>关键 1：理解题意</p><p>题目要我们找出和最大的连续子数组的值是多少，「连续」是关键字，连续很重要，不是子序列。</p><p>题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用「动态规划」解决。</p><p>关键 2：如何定义子问题（如何定义状态）</p><p>设计状态思路：把不确定的因素确定下来，进而把子问题定义清楚，把子问题定义得简单。动态规划的思想通过解决了一个一个简单的问题，进而把简单的问题的解组成了复杂的问题的解。</p><p>友情提示：上面这句话大家姑且这么一看，脑子里有个印象，没有那么绝对。可能不同的人看会有不同的理解。如果我以后讲解的动态规划的设计思想与这里讲解的「设计状态思路」不一样的，我会再和大家说明。如果讲解有误导的地方，还请大家指出。，</p><p>我们 不知道和最大的连续子数组一定会选哪一个数，那么我们可以求出 所有 经过输入数组的某一个数的连续子数组的最大和。</p><p>例如，示例 1 输入数组是 [-2,1,-3,4,-1,2,1,-5,4] ，我们可以求出以下子问题：</p><p>子问题 1：经过 -2−2 的连续子数组的最大和是多少；<br>子问题 2：经过 11 的连续子数组的最大和是多少；<br>子问题 3：经过 -3−3 的连续子数组的最大和是多少；<br>子问题 4：经过 44 的连续子数组的最大和是多少；<br>子问题 5：经过 -1−1 的连续子数组的最大和是多少；<br>子问题 6：经过 22 的连续子数组的最大和是多少；<br>子问题 7：经过 11 的连续子数组的最大和是多少；<br>子问题 8：经过 -5−5 的连续子数组的最大和是多少；<br>子问题 9：经过 44 的连续子数组的最大和是多少。<br>一共 9 个子问题，这些子问题之间的联系并没有那么好看出来，这是因为 子问题的描述还有不确定的地方（这件事情叫做「有后效性」，我们在本文的最后会讲解什么是「无后效性」）。</p><p>例如「子问题 3」：经过 -3−3 的连续子数组的最大和是多少。</p><p>「经过 -3−3 的连续子数组」我们任意举出几个：</p><p>[-2,1,-3,4] ，-3−3 是这个连续子数组的第 3 个元素；<br>[1,-3,4,-1] ，-3−3 是这个连续子数组的第 2 个元素；<br>……<br>我们不确定的是：-3−3 是连续子数组的第几个元素。那么我们就把 -3−3 定义成连续子数组的最后一个元素。在新的定义下，我们列出子问题如下：</p><p>子问题 1：以 -2−2 结尾的连续子数组的最大和是多少；<br>子问题 2：以 11 结尾的连续子数组的最大和是多少；<br>子问题 3：以 -3−3 结尾的连续子数组的最大和是多少；<br>子问题 4：以 44 结尾的连续子数组的最大和是多少；<br>子问题 5：以 -1−1 结尾的连续子数组的最大和是多少；<br>子问题 6：以 22 结尾的连续子数组的最大和是多少；<br>子问题 7：以 11 结尾的连续子数组的最大和是多少；<br>子问题 8：以 -5−5 结尾的连续子数组的最大和是多少；<br>子问题 9：以 44 结尾的连续子数组的最大和是多少。<br>我们加上了「结尾的」，这些子问题之间就有了联系。我们单独看子问题 1 和子问题 2：</p><p>子问题 1：以 -2−2 结尾的连续子数组的最大和是多少；<br>以 -2−2 结尾的连续子数组是 [-2]，因此最大和就是 -2−2。</p><p>子问题 2：以 11 结尾的连续子数组的最大和是多少；<br>以 11 结尾的连续子数组有 [-2,1] 和 [1] ，其中 [-2,1] 就是在「子问题 1」的后面加上 1 得到。-2 + 1 = -1 &lt; 1−2+1=−1&lt;1 ，因此「子问题 2」 的答案是 11。</p><p>大家发现了吗，如果编号为 i 的子问题的结果是负数或者 00 ，那么编号为 i + 1 的子问题就可以把编号为 i 的子问题的结果舍弃掉（这里 i 为整数，最小值为 1 ，最大值为 8），这是因为：</p><p>一个数 a 加上负数的结果比 a 更小；<br>一个数 a 加上 00 的结果不会比 a 更大；<br>而子问题的定义必须以一个数结尾，因此如果子问题 i 的结果是负数或者 00，那么子问题 i + 1 的答案就是以 nums[i] 结尾的那个数。<br>因为我们把子问题定义的更清楚，子问题之间的联系就容易观察到。这是我们定义子问题、定义状态的经验。</p><p>接下来我们按照编写动态规划题解的步骤，把「状态定义」「状态转移方程」「初始化」「输出」「是否可以空间优化」全都写出来。</p><p>定义状态（定义子问题）<br>dp[i]：表示以 nums[i] 结尾 的 连续 子数组的最大和。</p><p>说明：「结尾」和「连续」是关键字。</p><p>状态转移方程（描述子问题之间的联系）<br>根据状态的定义，由于 nums[i] 一定会被选取，并且以 nums[i] 结尾的连续子数组与以 nums[i - 1] 结尾的连续子数组只相差一个元素 nums[i] 。</p><p>假设数组 nums 的值全都严格大于 00，那么一定有 dp[i] = dp[i - 1] + nums[i]。</p><p>可是 dp[i - 1] 有可能是负数，于是分类讨论：</p><p>如果 dp[i - 1] &gt; 0，那么可以把 nums[i] 直接接在 dp[i - 1] 表示的那个数组的后面，得到和更大的连续子数组；<br>如果 dp[i - 1] &lt;= 0，那么 nums[i] 加上前面的数 dp[i - 1] 以后值不会变大。于是 dp[i] 「另起炉灶」，此时单独的一个 nums[i] 的值，就是 dp[i]。<br>以上两种情况的最大值就是 dp[i] 的值，写出如下状态转移方程：</p><p>dp[i] = \begin{cases} dp[i - 1] + nums[i], &amp; if \quad dp[i - 1] &gt; 0 \ nums[i], &amp; if \quad dp[i - 1] \le 0 \end{cases}<br>dp[i]={<br>dp[i−1]+nums[i],<br>nums[i],</p><p>ifdp[i−1]&gt;0<br>ifdp[i−1]≤0</p><p>记为「状态转移方程 1」。</p><p>状态转移方程还可以这样写，反正求的是最大值，也不用分类讨论了，就这两种情况，取最大即可，因此还可以写出状态转移方程如下：</p><p>dp[i] = \max {nums[i],\; dp[i - 1] + nums[i]}<br>dp[i]=max{nums[i],dp[i−1]+nums[i]}</p><p>记为「状态转移方程 2」。</p><p>友情提示：求解动态规划的问题经常要分类讨论，这是因为动态规划的问题本来就有「最优子结构」的特点，即大问题的最优解通常由小问题的最优解得到。因此我们在设计子问题的时候，就需要把求解出所有子问题的结果，进而选出原问题的最优解。</p><p>思考初始值<br>dp[0] 根据定义，只有 1 个数，一定以 nums[0] 结尾，因此 dp[0] = nums[0]。</p><p>思考输出<br>注意：</p><p>这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；</p><p>这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；</p><p>这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去。</p><p>重要的事情说三遍，有时候写东西写得多了，怕读者看不到重点，所以会想方设法进行强调，一句话翻来覆去反复说。我以前和一个在新东方当英语老师的朋友交流过，这样的效果最好。大家可以理解为职业病，我们更多是想要照顾到新手朋友们。大佬要是觉得我讲得啰嗦了，还请忽略。</p><p>简单的动态规划问题，很有可能问的问题就可以设计成为子问题，复杂的动态规划问题就没有那么容易看出子问题应该如何设计了，这需要一定的解决问题的经验。</p><p>这个问题的输出是把所有的 dp[0]、dp[1]、……、dp[n - 1] 都看一遍，取最大值。 同样的情况也适用于「力扣」第 300 题：「最长上升子序列」（以后我们有空，再把这道题拿出来再讲一遍，超级超级重要的一道动态规划问题）。</p><p>可以优化空间吗<br>根据「状态转移方程」，dp[i] 的值只和 dp[i - 1] 有关，因此可以使用「滚动变量」的方式将代码进行优化。</p><p>以下「参考代码 1」给出了不空间优化的代码，「参考代码 2」给出了空间优化的代码。</p><p>参考代码 1：</p><p>JavaPython3</p><p>public class Solution {</p><pre><code>public int maxSubArray(int[] nums) &#123;    int len = nums.length;    // dp[i] 表示：以 nums[i] 结尾的连续子数组的最大和    int[] dp = new int[len];    dp[0] = nums[0];    for (int i = 1; i &lt; len; i++) &#123;        if (dp[i - 1] &gt; 0) &#123;            dp[i] = dp[i - 1] + nums[i];        &#125; else &#123;            dp[i] = nums[i];        &#125;    &#125;    // 也可以在上面遍历的同时求出 res 的最大值，这里我们为了语义清晰分开写，大家可以自行选择    int res = dp[0];    for (int i = 1; i &lt; len; i++) &#123;        res = Math.max(res, dp[i]);    &#125;    return res;&#125;</code></pre><p>}<br>时间复杂度：O(N)O(N) ，这里 NN 是输入数组的长度。</p><p>参考代码 2：</p><p>public class Solution {</p><pre><code>public int maxSubArray(int[] nums) &#123;    int pre = 0;    int res = nums[0];    for (int num : nums) &#123;        pre = Math.max(pre + num, num);        res = Math.max(res, pre);    &#125;    return res;&#125;</code></pre><p>}<br>时间复杂度：O(N)O(N) ，这里 NN 是输入数组的长度。</p><p>这里再多说一点，如果是在 online judge 上写代码，我一般都不会写优化空间的代码，这是因为：</p><p>一般的问题只要时间复杂度最优就可以；<br>空间复杂度 online judge 并不在意，只要使用的空间不太离谱，不要一上来就 int[] dp = new int[Integer.MAX_VALUE] 就好；<br>优化空间的代码会丢失可读性，不好理解和向他人阐述。我自己写出来都困难，一般的流程是：先写一版不优化空间的代码，再写优化空间的代码。但是不优化空间的代码都可以通过系统测评了，我为什么还要写优化空间的代码呢？哈哈哈。<br>最后再谈谈「无后效性」<br>「无后效性」是我多次提到的一个「动态规划」中非常重要的概念，在我看来，理解这个概念无比重要。很遗憾，《算法导论》上没有讲到「无后效性」。我找了一本在「豆瓣」目前豆瓣上评分为 9.2 的书 《算法竞赛进阶指南》，这本书和《算法导论》《算法 4》和 liuyubobobo 老师的算法课程一样，在我学习算法与数据结构的道路上，都发挥了巨大的作用。</p><p>李煜东著《算法竞赛进阶指南》，摘录如下：：</p><p>为了保证计算子问题能够按照顺序、不重复地进行，动态规划要求已经求解的子问题不受后续阶段的影响。这个条件也被叫做「无后效性」。换言之，动态规划对状态空间的遍历构成一张有向无环图，遍历就是该有向无环图的一个拓扑序。有向无环图中的节点对应问题中的「状态」，图中的边则对应状态之间的「转移」，转移的选取就是动态规划中的「决策」。</p><p>我的解释：</p><p>「有向无环图」「拓扑序」表示了每一个子问题只求解一次，以后求解问题的过程不会修改以前求解的子问题的结果；<br>换句话说：如果之前的阶段求解的子问题的结果包含了一些不确定的信息，导致了后面的阶段求解的子问题无法得到，或者很难得到，这叫「有后效性」，我们在当前这个问题第 1 次拆分的子问题就是「有后效性」的（大家可以再翻到上面再看看）；<br>解决「有后效性」的办法是固定住需要分类讨论的地方，记录下更多的结果。在代码层面上表现为：<br>状态数组增加维度，例如：「力扣」的股票系列问题；<br>把状态定义得更细致、准确，例如：前天推送的第 124 题：状态定义只解决路径来自左右子树的其中一个子树。<br>总结<br>「动态规划」的解法，我们先告诉大家，理解题意非常重要。其次，我们在做「动态规划」的问题的时候，需要经常思考 为什么想到需要这样定义状态。</p><h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a><a href="https://leetcode.cn/problems/merge-sorted-array/">合并两个有序数组</a></h2><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><p>个人答解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Atest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.validation.Validator;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] n1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] n2=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        solution.merge(n1,<span class="number">3</span>,n2,<span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(n1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">                nums1[i]=nums2[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=m,j=<span class="number">0</span>;i&lt;nums1.length;i++,j++)&#123;</span><br><span class="line">                nums1[i]=nums2[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">                <span class="type">int</span> Val=nums1[i];</span><br><span class="line">                <span class="type">int</span> ValIndex=i-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (ValIndex&gt;=<span class="number">0</span>&amp;&amp;Val&lt;nums1[ValIndex])&#123;</span><br><span class="line">                    nums1[ValIndex+<span class="number">1</span>]=nums1[ValIndex];</span><br><span class="line">                    ValIndex--;</span><br><span class="line">                &#125;</span><br><span class="line">                nums1[ValIndex+<span class="number">1</span>]=Val;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此种解法过于冗长，且时间复杂度较高，以下是看了解答后的，自己进行的题解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Atest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.validation.Validator;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] n1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] n2=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        solution.merge(n1,<span class="number">3</span>,n2,<span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(n1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len1=m-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> len2=n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> all=m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (len1&gt;=<span class="number">0</span>&amp;&amp;len2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[len1]&gt;nums2[len2])&#123;</span><br><span class="line">                nums1[all]=nums1[len1];</span><br><span class="line">                len1--;</span><br><span class="line">                all--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[all]=nums2[len2];</span><br><span class="line">                len2--;</span><br><span class="line">                all--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(nums2,<span class="number">0</span>,nums1,<span class="number">0</span>,len2+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></h2><p> 给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。 </p><p>思路：<strong>看了题解后，采用快慢指针的方法，先让两指针产生大小为n的距离，再让两个指针一起向后移动，移动到null之前，再将需要删除的数给删除掉，最后用head返回。(ps：此处的头节点为单独的一个节点)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Atest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.validation.Validator;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>,head);</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        solution.removeNthFromEnd(head2,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        ListNode tar1=head;</span><br><span class="line">        ListNode tar2=head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            tar2=tar2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断一下头节点</span></span><br><span class="line">        <span class="keyword">if</span> (tar2==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> tar1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (tar2.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            tar1=tar1.next;</span><br><span class="line">            tar2=tar2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tar1.next=tar1.next.next;</span><br><span class="line">        <span class="keyword">return</span> tar1.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">      <span class="type">int</span> val;</span><br><span class="line">      ListNode next;</span><br><span class="line">      ListNode() &#123;&#125;</span><br><span class="line">      ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">      ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">合并两个有序链表</a></h2><h3 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p>思路</p><p>我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：</p><p>也就是说，两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并。</p><p>算法</p><p>我们直接将以上递归过程建模，同时需要考虑边界情况。</p><p>如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Atest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.validation.Validator;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list1.val&lt; list2.val) &#123;</span><br><span class="line">            list1.next=mergeTwoLists(list1.next,list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            list2.next=mergeTwoLists(list1,list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">      <span class="type">int</span> val;</span><br><span class="line">      ListNode next;</span><br><span class="line">      ListNode() &#123;&#125;</span><br><span class="line">      ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">      ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n + m)O(n+m)，其中 nn 和 mm 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)O(n+m)。</p><p>空间复杂度：O(n + m)O(n+m)，其中 nn 和 mm 分别为两个链表的长度。递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+mn+m 次，因此空间复杂度为 O(n+m)O(n+m)。</p><h3 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h3><p>思路</p><p>我们可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。</p><p>算法</p><p>首先，我们设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。</p><p>在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Atest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.validation.Validator;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">Prehead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,<span class="literal">null</span>);</span><br><span class="line">        ListNode head=Prehead;</span><br><span class="line">        <span class="keyword">while</span> (list1!=<span class="literal">null</span>&amp;&amp;list2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val&lt; list2.val)&#123;</span><br><span class="line">                head.next=list1;</span><br><span class="line">                list1=list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                head.next=list2;</span><br><span class="line">                list2=list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next=(list1==<span class="literal">null</span>?list2:list1);</span><br><span class="line">        <span class="keyword">return</span> Prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">      <span class="type">int</span> val;</span><br><span class="line">      ListNode next;</span><br><span class="line">      ListNode() &#123;&#125;</span><br><span class="line">      ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">      ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法(六)</title>
      <link href="/2023/01/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%85%AD/"/>
      <url>/2023/01/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法-六"><a href="#数据结构与算法-六" class="headerlink" title="数据结构与算法(六)"></a>数据结构与算法(六)</h1><p><strong>ps:从此片开始，后面开始研究最基础的算法</strong></p><h2 id="二分查找算法-非递归-介绍"><a href="#二分查找算法-非递归-介绍" class="headerlink" title="二分查找算法(非递归)介绍"></a>二分查找算法(非递归)介绍</h2><p>前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式</p><ol><li>二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找</li><li>二分查找法的运行时间为对数时间O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为㏒₂100 , 即最多需要查找7次( 2^6 &lt; 100 &lt; 2^7)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Algorithm.BinarySearchNoRecursion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchNo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">67</span>, <span class="number">100</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> binarySearch(arr,<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;要找到数是第&quot;</span>+(index+<span class="number">1</span>)+<span class="string">&quot;个&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分查找的非递归实现</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待查找的数组,arr升序排列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tar 需要查找到数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对应的下标，-1表示没有找到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[]arr,<span class="type">int</span> tar)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right= arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;<span class="comment">//说明可以继续查找</span></span><br><span class="line">            <span class="type">int</span> mid=(left+right) /<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid]==tar)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid]&gt;tar) &#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;<span class="comment">//需要向左边查找</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;<span class="comment">//需要向右边查找</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><h3 id="分治算法介绍"><a href="#分治算法介绍" class="headerlink" title="分治算法介绍"></a>分治算法介绍</h3><blockquote><p>分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……<br>分治算法可以求解的一些经典问题<br>二分搜索<br>大整数乘法<br>棋盘覆盖<br>合并排序<br>快速排序<br>线性时间选择<br>最接近点对问题<br>循环赛日程表<br>汉诺塔</p></blockquote><p><strong>分治法在每一层递归上都有三个步骤：</strong><br>    分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题<br>    解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题<br>    合并：将各个子问题的解合并为原问题的解。</p><p>分治(Divide-and-Conquer(P))算法设计模式如下：</p><p>if |P|≤n0<br>   then return(ADHOC(P))<br>//将P分解为较小的子问题 P1 ,P2 ,…,Pk<br>for i←1 to k<br>do yi ← Divide-and-Conquer(Pi)   递归解决Pi<br>T ← MERGE(y1,y2,…,yk)   合并子问题<br>return(T)</p><p>其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。</p><h3 id="分治算法最佳实践-汉诺塔"><a href="#分治算法最佳实践-汉诺塔" class="headerlink" title="分治算法最佳实践-汉诺塔"></a>分治算法最佳实践-汉诺塔</h3><ol><li>如果是有一个盘， A-&gt;C</li><li>如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘<ol><li>先把 最上面的盘 A-&gt;B</li><li>把最下边的盘 A-&gt;C</li><li>把B塔的所有盘 从 B-&gt;C   </li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Algorithm.Divide;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hanoitower</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        hanoiTower(<span class="number">3</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//汉诺塔的移动方法</span></span><br><span class="line">    <span class="comment">//使用分治算法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 盘子数目</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A 最开始盘子堆叠在A处</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> B B柱子是过渡用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> C C柱子是终点柱子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hanoiTower</span><span class="params">(<span class="type">int</span> num,<span class="type">char</span> A,<span class="type">char</span> B,<span class="type">char</span> C)</span>&#123;</span><br><span class="line">        <span class="comment">//如果只有一个盘</span></span><br><span class="line">        <span class="keyword">if</span> (num==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第1个盘从 &quot;</span>+ A+<span class="string">&quot;-&gt;&quot;</span>+C);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//在不少于两个的情况下，我们可以总是看成两个盘</span></span><br><span class="line">            <span class="comment">//1.先把 最上面的盘 A-&gt;B,移动过程使用C柱子</span></span><br><span class="line">            hanoiTower(num-<span class="number">1</span>,A,C,B);</span><br><span class="line">            <span class="comment">//2.把最下边的盘 A-&gt;C</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+num+<span class="string">&quot;个盘从 &quot;</span>+A+<span class="string">&quot;-&gt;&quot;</span>+C);</span><br><span class="line">            <span class="comment">//3.把B塔的所有盘 从 B-&gt;C ,移动过程使用A柱子</span></span><br><span class="line">            hanoiTower(num-<span class="number">1</span>,B,A,C);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h2><blockquote><p>动态规划算法介绍</p><p>1.动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法</p><p>2.动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p><p>3.与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )</p><p>4.动态规划可以通过填表的方式来逐步推进，得到最优解.</p><p>5.背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包(完全背包指的是：每种物品都有无限件可用)<br>(这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。)</p></blockquote><p>题目：</p><p><img src="../../Users/juan/AppData/Roaming/Typora/typora-user-images/1672314215465.png" alt="1672314215465"></p><p><strong>画表来解决：</strong></p><p><img src="../../Users/juan/AppData/Roaming/Typora/typora-user-images/1672312952050.png" alt="1672312952050"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i是行，j是列</span><br><span class="line">v[i][0]=v[0][j]=0;//表示填入表的第一行和第一列是0</span><br><span class="line">当w[i]&gt;j时：v[i][j]=v[i-1][j]//当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略</span><br><span class="line">当j&gt;=w[i]时：v[i][j]=max&#123;v[i-1][j],v[i-1][j-w[i]]+v[i]&#125;//当准备加入的新增的商品容量小于等于当前背包的容量</span><br><span class="line">装入的方式：</span><br><span class="line">v[i-1][j]:就是上一个单元格装入的最大值</span><br><span class="line">v[i]:表示当前商品的价值v[i-1][j-w[i]]:装入i-1商品，到剩余空间j-w[i]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Algorithm.Dynamic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KnapsackProblem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] w=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;<span class="comment">//物品的重量</span></span><br><span class="line">        <span class="type">int</span>[] value=&#123;<span class="number">1500</span>,<span class="number">3000</span>,<span class="number">2000</span>&#125;;<span class="comment">//物品的价值</span></span><br><span class="line">        <span class="type">int</span> m=<span class="number">4</span>;<span class="comment">//背包的容量</span></span><br><span class="line">        <span class="type">int</span> n= value.length;<span class="comment">//物品的个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了记录放入商品的情况，我们定义一个二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] path=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建二维数组，</span></span><br><span class="line">        <span class="comment">//v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大值</span></span><br><span class="line">        <span class="type">int</span>[][] v=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化第一行和第一列,这里在本程序中可以不去处理，因为默认为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.length;i++)&#123;</span><br><span class="line">            v[i][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//将第一列设置为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;v[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">            v[<span class="number">0</span>][i]=<span class="number">0</span>;<span class="comment">//将第一行设置为0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据前面得到的公式，来动态规划处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;v.length;i++)&#123;<span class="comment">//不处理第一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;v[<span class="number">0</span>].length;j++)&#123;<span class="comment">//不处理第一列</span></span><br><span class="line">                <span class="comment">//公式</span></span><br><span class="line">                <span class="keyword">if</span> (w[i-<span class="number">1</span>]&gt;j)&#123;<span class="comment">//因为程序i是从1开始，原来公式中的w[i]修改成w[i-1]</span></span><br><span class="line">                    v[i][j]=v[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//为了记录商品存放到背包得到情况，不能使用简单的公式</span></span><br><span class="line">                    <span class="comment">//需要使用if-else</span></span><br><span class="line">                    <span class="keyword">if</span> (v[i-<span class="number">1</span>][j]&lt;value[i-<span class="number">1</span>]+v[i-<span class="number">1</span>][j-w[i-<span class="number">1</span>]])&#123;</span><br><span class="line">                        v[i][j]=value[i-<span class="number">1</span>]+v[i-<span class="number">1</span>][j-w[i-<span class="number">1</span>]];<span class="comment">//value和w数组都要减1</span></span><br><span class="line">                        path[i][j]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        v[i][j]=v[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出v，查看情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;v[i].length;j++)&#123;</span><br><span class="line">                System.out.print(v[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出我们最后放入的是哪些</span></span><br><span class="line">        <span class="comment">//这样输出有冗余,算上了所有的情况，我们只需要最后放入的情况</span></span><br><span class="line"><span class="comment">//        for(int i=0;i&lt; path.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//            for (int j=0;j&lt;path[i].length;j++)&#123;</span></span><br><span class="line"><span class="comment">//                if (path[i][j]==1)&#123;</span></span><br><span class="line"><span class="comment">//                    System.out.printf(&quot;第%d个商品放入到背包\n&quot;,i);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="type">int</span> i= path.length-<span class="number">1</span>;<span class="comment">//行下标最大值</span></span><br><span class="line">        <span class="type">int</span> j= path[<span class="number">0</span>].length-<span class="number">1</span>;<span class="comment">//列的下标最大值</span></span><br><span class="line">        <span class="keyword">while</span> (i&gt;<span class="number">0</span>&amp;&amp;j&gt;<span class="number">0</span>)&#123;<span class="comment">//从path数组的最后开始找</span></span><br><span class="line">            <span class="keyword">if</span> (path[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;第%d个商品放入到背包\n&quot;</span>,i);</span><br><span class="line">                j-=w[i-<span class="number">1</span>];<span class="comment">//所占重量是w[i-1]</span></span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>思路总结：</strong></p><p>使用sum[i][j]记录前i个物品，背包容量为j时所能获取的最大价值</p><ul><li>1，当i或j为0时sum[i][j]=0,应为前0个物品或者背包容量为0时，装载最大价值=0</li><li>2，使用两层循环，外层循环代表物品数量1…n增加，内层循环控制背包容量从1…n增加</li><li>3，（1）当前背包容量j&lt;第i个物品占用位置大小时，则不要此物品，sum[i][j]=sum[i-1][j]</li><li>(2)当前背包容量j&gt;=第i个物品占用大小时，选择一下情况中价值量大的</li><li>【1】 不要此物品sum[i][j]=sum[i-1][j];</li><li>【2】 放入此物品，那么就需要保证背包可以装下此物品，使用转移方程 sum[i][j]=sum[i-1][j-商品占用大小]</li><li>4，dp[物品数量][背包大小]即为最终结果</li></ul><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="暴力匹配算法"><a href="#暴力匹配算法" class="headerlink" title="暴力匹配算法"></a>暴力匹配算法</h3><p>如果用暴力匹配的思路，并假设现在str1匹配到 i 位置，子串str2匹配到 j 位置，则有:</p><ol><li>如果当前字符匹配成功（即str1[i] == str2[j]），则i++，j++，继续匹配下一个字符</li><li>如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</li><li>用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!)</li><li>暴力匹配算法实现.</li></ol><p><strong>暴力匹配：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Algorithm.KMP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Violence</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String str1=<span class="string">&quot;硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好&quot;</span>;</span><br><span class="line">        String str2=<span class="string">&quot;尚硅谷你尚硅你&quot;</span>;</span><br><span class="line">        <span class="type">int</span> index=violenceMatch(str1,str2);</span><br><span class="line">        System.out.println(<span class="string">&quot;index=&quot;</span>+(index+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//暴力匹配算法实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">violenceMatch</span><span class="params">(String str1,String str2)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] s1=str1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] s2=str2.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> s1Len=s1.length;</span><br><span class="line">        <span class="type">int</span> s2Len= s2.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;<span class="comment">//i索引指向s1,j索引指向s2</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;s1Len&amp;&amp;j&lt;s2Len)&#123;<span class="comment">//此处说明还没有越界,保证匹配时，不越界</span></span><br><span class="line">            <span class="keyword">if</span> (s1[i]==s2[j])&#123;<span class="comment">//说明匹配成功</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//说明没有匹配成功</span></span><br><span class="line">                <span class="comment">//如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0</span></span><br><span class="line">                i = i - (j - <span class="number">1</span>);</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> (j==s2Len)&#123;</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="KMP算法介绍："><a href="#KMP算法介绍：" class="headerlink" title="KMP算法介绍："></a>KMP算法介绍：</h3><p><strong>具体看另外一篇博客。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Algorithm.KMP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMPAlgorithm</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String str1=<span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;<span class="comment">//文字串</span></span><br><span class="line">        String str2=<span class="string">&quot;ABCDABD&quot;</span>;<span class="comment">//字串</span></span><br><span class="line">        <span class="type">int</span> res=KmpSearch(str1,str2,KmpNext(str2));</span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写出kmp的搜索算法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 原字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 需要检索寻找的子串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 部分匹配表，是字串对应的部分匹配表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> -1就是没有匹配到，否则返回第一个匹配的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">KmpSearch</span><span class="params">(String str1,String str2,<span class="type">int</span>[] next)</span>&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;str1.length();i++)&#123;</span><br><span class="line">            <span class="comment">//核心</span></span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span>&amp;&amp;str1.charAt(i)!=str2.charAt(j))&#123;</span><br><span class="line">                j=next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i)==str2.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                j=j+next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j==str2.length())&#123;<span class="comment">//说明找到了</span></span><br><span class="line">                <span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.先写一个方法，获取到一个字符串(子串)的部分匹配值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] KmpNext(String dest)&#123;</span><br><span class="line">        <span class="comment">//创建一个next数组保存部分匹配值</span></span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[dest.length()];</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//如果字符串是长度为1，部分匹配值就是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;dest.length();i++)&#123;</span><br><span class="line">            <span class="comment">//当dest.charAt(i)！=dest.charAt(j)时，我们需要从next[j-1]获取新的j</span></span><br><span class="line">            <span class="comment">//直到我们发现有dest.charAt(i)==dest.charAt(j)时，才退出</span></span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span>&amp;&amp;dest.charAt(i)!=dest.charAt(j))&#123;</span><br><span class="line">                <span class="comment">//j就是最大前缀所对应的字母，i就是目前指向的字母,j指向就是前缀的前缀</span></span><br><span class="line">                <span class="comment">//如果不匹配，那就让j往前，不断匹配</span></span><br><span class="line">                j=next[j-<span class="number">1</span>];<span class="comment">//此处是核心,j=next[j-1]代表j从0开始移动next[j-1]下</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当dest.charAt(i)==dest.charAt(j)满足时，部分匹配值就是+1</span></span><br><span class="line">            <span class="keyword">if</span> (dest.charAt(i)==dest.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><blockquote><p>贪心算法介绍</p><p>贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法</p><p>贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果</p></blockquote><p>此处，博主学习的视频中的太过垃圾，等以后有好的案例，再进行补充。</p><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>有胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在需要修路把7个村庄连通<br>各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里<br>问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?<br>思路: 将10条边，连接即可，但是总的里程数不是最小.<br>正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少. </p><p><strong>本质就是找节点</strong></p><p>修路问题本质就是就是最小生成树问题， 先介绍一下最小生成树(Minimum Cost Spanning Tree)，简称MST。</p><ol><li>给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树 </li><li>N个顶点，一定有N-1条边</li><li>包含全部顶点</li><li>N-1条边都在图中<br>求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法</li></ol><p>普里姆算法介绍</p><p>普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图<br>普利姆的算法如下:</p><ol><li>普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图</li><li>设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合 </li><li>若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1</li><li>若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，标记visited[vj]=1</li><li>重复步骤②，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边<br>提示: 单独看步骤很难理解，我们通过代码来讲解，比较好理解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Algorithm.Prim;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">prim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] data=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> verxs= data.length;</span><br><span class="line">        <span class="comment">//邻接矩阵的关系使用二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] weight=&#123;&#123;<span class="number">10000</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">5</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10000</span>,<span class="number">6</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10000</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建MGraph的对象</span></span><br><span class="line">        <span class="type">Mgraph</span> <span class="variable">mgraph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mgraph</span>(verxs);</span><br><span class="line">        <span class="comment">//创建一个MinTree对象</span></span><br><span class="line">        <span class="type">MinTree</span> <span class="variable">minTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinTree</span>();</span><br><span class="line">        minTree.createGraph(mgraph,verxs,data,weight);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        minTree.showGraph(mgraph);</span><br><span class="line">        <span class="comment">//测试Prim算法</span></span><br><span class="line">        minTree.prim(mgraph,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建最小生成树-&gt;村庄的图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinTree</span>&#123;</span><br><span class="line">    <span class="comment">//创建图的邻接矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mgraph 图对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> verxs 图的顶点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 图的各个顶点值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 图的邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createGraph</span><span class="params">(Mgraph mgraph,<span class="type">int</span> verxs,<span class="type">char</span>[] data,<span class="type">int</span>[][] weight)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span> ( i=<span class="number">0</span>;i&lt;verxs;i++)&#123;<span class="comment">//顶点</span></span><br><span class="line">          mgraph.data[i]=data[i];</span><br><span class="line">          <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;verxs;j++)&#123;</span><br><span class="line">              mgraph.weight[i][j]=weight[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示图的方法</span></span><br><span class="line">    <span class="comment">//显示图的邻接矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">(Mgraph mgraph)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] link:mgraph.weight)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写prim算法，得到最小生成树</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mgraph 图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 表示从图的第几个顶点开始生成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prim</span><span class="params">(Mgraph mgraph,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] visited = <span class="keyword">new</span> <span class="title class_">int</span>[mgraph.verxs];<span class="comment">//表示存放已经访问过的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//把当前这个节点标记为已访问</span></span><br><span class="line">        visited[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//h1和h2记录两个顶点的下标</span></span><br><span class="line">        <span class="type">int</span> h1=-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> h2=-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> minWeight=<span class="number">10000</span>;<span class="comment">//将minWeight初始化成一个大数，后面遍历过程中，会被替换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;mgraph.verxs;k++)&#123;<span class="comment">//会默认生成  节点数-1  条边</span></span><br><span class="line">            <span class="comment">//这个是确定每一次生成的子图,和哪个节点的距离最近</span></span><br><span class="line">            <span class="comment">// i,j的两轮循环一次只能找到一个节点，并将这个节点记录</span></span><br><span class="line">            <span class="comment">//接着通过k循环  总结点数-1  次后，所有的节点就都能找到了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;mgraph.verxs;i++)&#123;<span class="comment">//i节点表示被访问过的节点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;mgraph.verxs;j++)&#123;<span class="comment">//j节点表示还没有访问过的节点</span></span><br><span class="line">                    <span class="keyword">if</span> (visited[i]==<span class="number">1</span>&amp;&amp;visited[j]==<span class="number">0</span>&amp;&amp;mgraph.weight[i][j]&lt;minWeight)&#123;</span><br><span class="line">                        <span class="comment">//替换minWeight</span></span><br><span class="line">                        minWeight=mgraph.weight[i][j];</span><br><span class="line">                        h1=i;</span><br><span class="line">                        h2=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//退出for循环，已经找到了一条边最小</span></span><br><span class="line">            System.out.println(<span class="string">&quot;边&lt;&quot;</span>+mgraph.data[h1]+<span class="string">&quot;,&quot;</span>+mgraph.data[h2]+<span class="string">&quot;&gt;权值:&quot;</span>+minWeight);</span><br><span class="line">            <span class="comment">//将当前这个找到的节点，标记为已经访问</span></span><br><span class="line">            visited[h2]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//minWeight重新设置为最大值</span></span><br><span class="line">            minWeight=<span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mgraph</span>&#123;</span><br><span class="line">    <span class="type">int</span> verxs;<span class="comment">//表示节点</span></span><br><span class="line">    <span class="type">char</span>[] data;<span class="comment">//存放节点数据</span></span><br><span class="line">    <span class="type">int</span>[][] weight;<span class="comment">//存放变，就是我们的邻接矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mgraph</span><span class="params">(<span class="type">int</span> verxs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.verxs = verxs;</span><br><span class="line">        data=<span class="keyword">new</span> <span class="title class_">char</span>[verxs];</span><br><span class="line">        weight=<span class="keyword">new</span> <span class="title class_">int</span>[verxs][verxs];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kruskal-克鲁斯卡尔算法"><a href="#Kruskal-克鲁斯卡尔算法" class="headerlink" title="Kruskal(克鲁斯卡尔算法)"></a>Kruskal(克鲁斯卡尔算法)</h2><h3 id="克鲁斯卡尔算法介绍"><a href="#克鲁斯卡尔算法介绍" class="headerlink" title="克鲁斯卡尔算法介绍"></a>克鲁斯卡尔算法介绍</h3><blockquote><p>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。<br>基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路<br>具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止</p></blockquote><p><strong>本质就是找权值小的边</strong></p><p> 将边添加到最小生成树中时，怎么样判断是否形成了回路。 </p><p> <strong>处理方式是：记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Algorithm.Kruskal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kruskal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> edgeNum;<span class="comment">//边的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] vertexes;<span class="comment">//顶点数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] matrix;<span class="comment">//邻接矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用INF表示两个顶点不能连通</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span>Integer.MAX_VALUE;<span class="comment">//Integer.MAX_VALUE表示int数据类型的最大取值数：2 147 483 647</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] vertexes=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;<span class="comment">//此处就进行了初始化</span></span><br><span class="line">        <span class="comment">//克鲁斯卡尔算法的邻接矩阵</span></span><br><span class="line">        <span class="type">int</span> matrix[][] = &#123;</span><br><span class="line">                <span class="comment">/*A*/</span><span class="comment">/*B*/</span><span class="comment">/*C*/</span><span class="comment">/*D*/</span><span class="comment">/*E*/</span><span class="comment">/*F*/</span><span class="comment">/*G*/</span></span><br><span class="line">                <span class="comment">/*A*/</span> &#123;   <span class="number">0</span>,  <span class="number">12</span>, INF, INF, INF,  <span class="number">16</span>,  <span class="number">14</span>&#125;,</span><br><span class="line">                <span class="comment">/*B*/</span> &#123;  <span class="number">12</span>,   <span class="number">0</span>,  <span class="number">10</span>, INF, INF,   <span class="number">7</span>, INF&#125;,</span><br><span class="line">                <span class="comment">/*C*/</span> &#123; INF,  <span class="number">10</span>,   <span class="number">0</span>,   <span class="number">3</span>,   <span class="number">5</span>,   <span class="number">6</span>, INF&#125;,</span><br><span class="line">                <span class="comment">/*D*/</span> &#123; INF, INF,   <span class="number">3</span>,   <span class="number">0</span>,   <span class="number">4</span>, INF, INF&#125;,</span><br><span class="line">                <span class="comment">/*E*/</span> &#123; INF, INF,   <span class="number">5</span>,   <span class="number">4</span>,   <span class="number">0</span>,   <span class="number">2</span>,   <span class="number">8</span>&#125;,</span><br><span class="line">                <span class="comment">/*F*/</span> &#123;  <span class="number">16</span>,   <span class="number">7</span>,   <span class="number">6</span>, INF,   <span class="number">2</span>,   <span class="number">0</span>,   <span class="number">9</span>&#125;,</span><br><span class="line">                <span class="comment">/*G*/</span> &#123;  <span class="number">14</span>, INF, INF, INF,   <span class="number">8</span>,   <span class="number">9</span>,   <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">Kruskal</span> <span class="variable">kruskalCase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kruskal</span>(vertexes, matrix);</span><br><span class="line">        <span class="comment">//输出构建的是否正确</span></span><br><span class="line">        kruskalCase.print();</span><br><span class="line">        kruskalCase.kruskal();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//初始化两个数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Kruskal</span><span class="params">(<span class="type">char</span>[] vertexes, <span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="comment">//这种初始化方法比默认的初始化方法要更加安全些</span></span><br><span class="line">        <span class="comment">//初始化顶点数和边的个数</span></span><br><span class="line">       <span class="type">int</span> vlen= vertexes.length;</span><br><span class="line">       <span class="comment">//初始化顶点</span></span><br><span class="line">        <span class="built_in">this</span>.vertexes=<span class="keyword">new</span> <span class="title class_">char</span>[vlen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;vertexes.length;i++)&#123;</span><br><span class="line">            <span class="built_in">this</span>.vertexes[i]=vertexes[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化边，使用的是复制拷贝的方式</span></span><br><span class="line">        <span class="built_in">this</span>.matrix=<span class="keyword">new</span> <span class="title class_">int</span>[vlen][vlen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;vlen;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;vlen;j++)&#123;</span><br><span class="line">                <span class="built_in">this</span>.matrix[i][j]=matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计边的条数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;vlen;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;vlen;j++)&#123;<span class="comment">//为了排除自己和自己连接</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.matrix[i][j]!=INF)&#123;</span><br><span class="line">                    edgeNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kruskal</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//表示结果数组的索引</span></span><br><span class="line">        <span class="type">int</span>[] ends=<span class="keyword">new</span> <span class="title class_">int</span>[edgeNum];<span class="comment">//用于保存&quot;已有最小生成树&quot;中的每个顶点在最小生成树中的终点</span></span><br><span class="line">        <span class="comment">//创建结果数组，保存最后的最小生成树</span></span><br><span class="line">        EData[] rets=<span class="keyword">new</span> <span class="title class_">EData</span>[edgeNum];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取图中所有的边的集合,一共有12条边</span></span><br><span class="line">        EData[] edges=getEdges();</span><br><span class="line">        <span class="comment">//按照边的权值大小进行排序</span></span><br><span class="line">        sortEdge(edges);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历edges数组，将边添加到最小生成树中，判断准备加入的边是否生成了回路,如果没有构成，就加入rets</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;edgeNum;i++)&#123;</span><br><span class="line">            <span class="comment">//1.获取到第i条边的第一个顶点(起点)</span></span><br><span class="line">            <span class="type">int</span> p1=getPosition(edges[i].start);</span><br><span class="line">            <span class="comment">//2.获取第i条边的第二个顶点(终点)</span></span><br><span class="line">            <span class="type">int</span> p2=getPosition(edges[i].end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取p1这个顶点在已有的最小生成树中的终点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> getEnd(ends,p1);</span><br><span class="line">            <span class="comment">//获取p2这个顶点在已有最小生成树中的终点</span></span><br><span class="line">            <span class="type">int</span> n=getEnd(ends,p2);</span><br><span class="line">            <span class="comment">//判断是否构成回路</span></span><br><span class="line">            <span class="keyword">if</span> (m!=n)&#123;<span class="comment">//说明不构成回路</span></span><br><span class="line">                ends[m]=n;<span class="comment">//设置m在&quot;已有最小生成树的终点&quot;</span></span><br><span class="line">                rets[index++]=edges[i];<span class="comment">//有一条边加入到数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计并打印最小生成树,输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最小生成树为=&quot;</span>+Arrays.toString(rets));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印邻接矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;邻接矩阵为：\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; vertexes.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt; vertexes.length;j++)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%20d&quot;</span>,matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对边进行排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> edges 这是边的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sortEdge</span><span class="params">(EData[] edges)</span>&#123;</span><br><span class="line">        EData temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; edges.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;edges.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (edges[j].weight&gt;edges[j+<span class="number">1</span>].weight)&#123;</span><br><span class="line">                    temp=edges[j];</span><br><span class="line">                    edges[j]=edges[j+<span class="number">1</span>];</span><br><span class="line">                    edges[j+<span class="number">1</span>]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ch 顶点的值，比如’A‘,&#x27;B&#x27;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回ch对应顶点的下标，找不到返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">char</span> ch)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; vertexes.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vertexes[i]==ch)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：获取图中边，放到EData[]中，后面我们需要遍历该数组</span></span><br><span class="line"><span class="comment">     * 是通过martix邻接矩阵来获取</span></span><br><span class="line"><span class="comment">     * EData形式[&#x27;A&#x27;,&#x27;B&#x27;,12]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> EData[] getEdges()&#123;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        EData[] edges = <span class="keyword">new</span> <span class="title class_">EData</span>[edgeNum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; vertexes.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt; vertexes.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j]!=INF)&#123;</span><br><span class="line">                    edges[index++]=<span class="keyword">new</span> <span class="title class_">EData</span>(vertexes[i],vertexes[j],matrix[i][j] );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：获取下标为i的顶点的终点,用于判断两个顶点的终点是否相同</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ends 数组就是记录了各个顶点对应的终点是哪个，ends数组是在遍历过程中逐步形成的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 表示传入的顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的就是下标为i的这个顶点对应的终点的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getEnd</span><span class="params">(<span class="type">int</span>[] ends,<span class="type">int</span> i)</span>&#123;<span class="comment">//此处是核心</span></span><br><span class="line">        <span class="keyword">while</span> (ends[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            i=ends[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个类EData,他的对象实例就表示一条边</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EData</span>&#123;</span><br><span class="line">    <span class="type">char</span> start;<span class="comment">//边的起点,边的一个点</span></span><br><span class="line">    <span class="type">char</span> end;<span class="comment">//边的终点，边的另外一个点</span></span><br><span class="line">    <span class="type">int</span> weight;<span class="comment">//边的权值</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EData</span><span class="params">(<span class="type">char</span> start, <span class="type">char</span> end, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写toString方法，便于输出边的信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;EData&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;start=&quot;</span> + start +</span><br><span class="line">                <span class="string">&quot;, end=&quot;</span> + end +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迪杰斯特拉-Dijkstra-算法"><a href="#迪杰斯特拉-Dijkstra-算法" class="headerlink" title="迪杰斯特拉(Dijkstra)算法"></a>迪杰斯特拉(Dijkstra)算法</h2><blockquote><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。 它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p></blockquote><p>设置出发顶点为v，顶点集合V{v1,v2,vi…}，v到V中各顶点的距离构成距离集合Dis，Dis{d1,d2,di…}，Dis集合记录着v到图中各顶点的距离(到自身可以看作0，v到vi距离对应为di)</p><ol><li>从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径</li><li>更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为vi，表明是通过vi到达的)</li><li>重复执行两步骤，直到最短路径顶点为目标顶点即可结束</li></ol><p>核心步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）dist[]存储第i个节点到家的距离，visited[i]=true 代表第i个点是否已经遍历过。</span><br><span class="line">2）遍历所有visited[i] == false的点，找出dist[i]最小的点 k。</span><br><span class="line">3）遍历与k相连的点j，用 min(dist[j], dist[k] + edge[k][j])来更新 dist[j]。</span><br><span class="line">4）将visited[k] = true;</span><br><span class="line">5)  如果还存在点，返回2）</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Algorithm.Dijkstra;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dijkstra</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] vertex=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="comment">//邻接矩阵</span></span><br><span class="line">        <span class="type">int</span>[][] matrix=<span class="keyword">new</span> <span class="title class_">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="keyword">final</span>  <span class="type">int</span> N=<span class="number">65535</span>;<span class="comment">//表示不可连接</span></span><br><span class="line">        matrix[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;N,<span class="number">5</span>,<span class="number">7</span>,N,N,N,<span class="number">2</span>&#125;;</span><br><span class="line">        matrix[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">5</span>,N,N,<span class="number">9</span>,N,N,<span class="number">3</span>&#125;;</span><br><span class="line">        matrix[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">7</span>,N,N,N,<span class="number">8</span>,N,N&#125;;</span><br><span class="line">        matrix[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;N,<span class="number">9</span>,N,N,N,<span class="number">4</span>,N&#125;;</span><br><span class="line">        matrix[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;N,N,<span class="number">8</span>,N,N,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        matrix[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;N,N,N,<span class="number">4</span>,<span class="number">5</span>,N,<span class="number">6</span>&#125;;</span><br><span class="line">        matrix[<span class="number">6</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">2</span>,<span class="number">3</span>,N,N,<span class="number">4</span>,<span class="number">6</span>,N&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(vertex, matrix);</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        graph.dsj(<span class="number">6</span>);</span><br><span class="line">        graph.showDjs();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建了一个图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] vertex;<span class="comment">//顶点数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] matrix;<span class="comment">//邻接矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> VisitedVertex vv;<span class="comment">//表示已经访问的顶点的集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//之前是拷贝，现在是使用引用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">char</span>[] vertex, <span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertex = vertex;</span><br><span class="line">        <span class="built_in">this</span>.matrix = matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showDjs</span><span class="params">()</span>&#123;</span><br><span class="line">        vv.show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//用增强for循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] link:matrix)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迪杰斯特拉(Dijkstra)算法实现</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 表示出发顶点对应的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dsj</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">         vv = <span class="keyword">new</span> <span class="title class_">VisitedVertex</span>(vertex.length, index);</span><br><span class="line">         update(index);<span class="comment">//更新index顶点到周围顶点的距离和前驱顶点,第一个顶点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt; vertex.length;j++)&#123;</span><br><span class="line">            index=vv.updateArr();<span class="comment">//选择并返回新的访问顶点</span></span><br><span class="line">            update(index);<span class="comment">//更新index顶点到周围顶点的距离和前驱顶点，剩余的顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新index下标顶点到周围顶点的距离和周围顶点的前驱顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//根据遍历我们的邻接矩阵的matrix[index]行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;matrix[index].length;j++)&#123;</span><br><span class="line">            <span class="comment">//len含义是：出发顶点到index顶点距离+从index顶点到j顶点的距离的和</span></span><br><span class="line">            len= vv.getDis(index)+ matrix[index][j];</span><br><span class="line">            <span class="comment">//如果j顶点没有被访问，并且len小于出发顶点到j顶点的距离，就需要更新</span></span><br><span class="line">            <span class="keyword">if</span> (!vv.in(j)&amp;&amp;len&lt; vv.getDis(j))&#123;</span><br><span class="line">                vv.updatePre(j,index);<span class="comment">//更新j顶点的前驱为index顶点</span></span><br><span class="line">                vv.updateDis(j,len);<span class="comment">//更新出发顶点到j顶点的距离</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VisitedVertex</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] already_arr;<span class="comment">//记录各个顶点是否访问过，1表示访问过，0表示未访问，动态更新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] pre_visited;<span class="comment">//每个下标对应的值为前一个顶点的下标，会动态更新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dis;<span class="comment">////记录出发顶点到其它所有顶点的距离,会动态更新</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 表示顶点的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 表示出发顶点对应的下标,比如G顶点，下标就是6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VisitedVertex</span><span class="params">(<span class="type">int</span> length,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.already_arr=<span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="built_in">this</span>.pre_visited=<span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="built_in">this</span>.dis=<span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="comment">//初始化dis数组</span></span><br><span class="line">        Arrays.fill(dis,<span class="number">65535</span>);</span><br><span class="line">        <span class="built_in">this</span>.already_arr[index]=<span class="number">1</span>;<span class="comment">//设置出发顶点访问过</span></span><br><span class="line">        <span class="built_in">this</span>.dis[index]=<span class="number">0</span>;<span class="comment">//设置出发顶点的访问距离为0</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断index下标对应的顶点是否被访问过</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果访问过，就返回一个true，否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">in</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> already_arr[index] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新出发顶点到index顶点的距离</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateDis</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">        dis[index]=len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新pre节点的前驱为index的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatePre</span><span class="params">(<span class="type">int</span> pre,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        pre_visited[pre]=index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回出发顶点到index顶点的距离</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDis</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续选择并返回新的访问节点，比如这里的G完后，就是A点作为新的访问顶点(注意不是出发顶点)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateArr</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> min=<span class="number">65535</span>,index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;already_arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (already_arr[i]==<span class="number">0</span>&amp;&amp;dis[i]&lt;min)&#123;</span><br><span class="line">                min = dis[i];</span><br><span class="line">                index=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新index顶点被访问过</span></span><br><span class="line">        already_arr[index]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示最后的结果</span></span><br><span class="line">    <span class="comment">//即，将三个数组的情况输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:already_arr)&#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:pre_visited)&#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:dis)&#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="弗洛伊德-Floyd-算法"><a href="#弗洛伊德-Floyd-算法" class="headerlink" title="弗洛伊德(Floyd)算法"></a>弗洛伊德(Floyd)算法</h2><blockquote><p>和Dijkstra算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名<br>弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径<br>迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。<br>弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。</p></blockquote><ol><li>设置顶点vi到顶点vk的最短路径已知为Lik，顶点vk到vj的最短路径已知为Lkj，顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min((Lik+Lkj),Lij)，vk的取值为图中所有顶点，则可获得vi到vj的最短路径</li><li>至于vi到vk的最短路径Lik或者vk到vj的最短路径Lkj，是以同样的方式获得</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Algorithm.Floyd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Floyd</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] vertex=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[][] matrix=<span class="keyword">new</span> <span class="title class_">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> N=<span class="number">65535</span>;</span><br><span class="line">        matrix[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, N, N, N, <span class="number">2</span> &#125;;</span><br><span class="line">        matrix[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">5</span>, <span class="number">0</span>, N, <span class="number">9</span>, N, N, <span class="number">3</span> &#125;;</span><br><span class="line">        matrix[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">7</span>, N, <span class="number">0</span>, N, <span class="number">8</span>, N, N &#125;;</span><br><span class="line">        matrix[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; N, <span class="number">9</span>, N, <span class="number">0</span>, N, <span class="number">4</span>, N &#125;;</span><br><span class="line">        matrix[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; N, N, <span class="number">8</span>, N, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        matrix[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; N, N, N, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span> &#125;;</span><br><span class="line">        matrix[<span class="number">6</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">2</span>, <span class="number">3</span>, N, N, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(vertex.length, matrix, vertex);</span><br><span class="line">        graph.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] vertex;<span class="comment">//存放顶点的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dis;<span class="comment">//保存从各个定点出发，到其他顶点的距离，最后的结果，也是保留在该数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] pre;<span class="comment">//保存到达目标顶点的前驱顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 邻接矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> length,<span class="type">int</span>[][] matrix,<span class="type">char</span>[] vertex)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.vertex=vertex;</span><br><span class="line">        <span class="built_in">this</span>.dis=matrix;</span><br><span class="line">        <span class="built_in">this</span>.pre=<span class="keyword">new</span> <span class="title class_">int</span>[length][length];</span><br><span class="line">        <span class="comment">//对pre数组初始化,存放的是前驱顶点的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            Arrays.fill(pre[i],i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示pre数组和dis数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] vertex=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt; dis.length;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; dis.length;i++)&#123;</span><br><span class="line">                System.out.print(vertex[pre[k][i]]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="comment">//输出dis数组的一行数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; dis.length;i++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;(&quot;</span>+vertex[k]+<span class="string">&quot;到&quot;</span> +vertex[i]+ <span class="string">&quot;的最短路径是&quot;</span>+dis[k][i]+<span class="string">&quot;) &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">floyd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;<span class="comment">//记录变量保存距离</span></span><br><span class="line">        <span class="comment">//从中间顶点的遍历,k就是中间顶点的下标[A,B,C,D,E,F,G]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt; dis.length;k++)&#123;</span><br><span class="line">            <span class="comment">//从i顶点开始出发[A,B,C,D,E,F,G]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; dis.length;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt; dis.length;j++)&#123;</span><br><span class="line">                    len=dis[i][k]+dis[k][j];<span class="comment">//求出从i节点出发，经过k中间顶点，到达j顶点的距离</span></span><br><span class="line">                    <span class="keyword">if</span> (len&lt;dis[i][j])&#123;<span class="comment">//如果len小于dis[i][j]直连距离</span></span><br><span class="line">                        dis[i][j]=len;</span><br><span class="line">                        pre[i][j]=pre[k][j];<span class="comment">//更新前驱顶点</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结：至此，基础数据结构的学习结束，作者可能只算刚刚入门一些，接下来就是继续学习，共勉努力吧。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法(五)</title>
      <link href="/2022/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%94/"/>
      <url>/2022/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法-五"><a href="#数据结构与算法-五" class="headerlink" title="数据结构与算法(五)"></a>数据结构与算法(五)</h1><h2 id="多路查找树："><a href="#多路查找树：" class="headerlink" title="多路查找树："></a>多路查找树：</h2><h3 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a>多叉树</h3><ol><li>在二叉树中，每个节点有数据项，最多有两个子节点。<strong>如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree）</strong></li><li>后面我们讲解的2-3树，2-3-4树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。</li></ol><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p><img src="../../Users/juan/AppData/Roaming/Typora/typora-user-images/1672109713324.png" alt="1672109713324"></p><ol><li>如图B树通过重新组织节点， 降低了树的高度.</li><li>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样每个节点只需要一次I/O就可以完全载入</li><li>将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素, B树(B+)广泛应用于文件存储系统以及数据库系统中(某个节点的子节点数最多的那个数值，就是树的度)</li></ol><h4 id="2-3树基本介绍"><a href="#2-3树基本介绍" class="headerlink" title="2-3树基本介绍"></a>2-3树基本介绍</h4><p>2-3树是最简单的B树结构, 具有如下特点:</p><ol><li>2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</li><li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</li><li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.</li><li>2-3树是由二节点和三节点构成的树。</li></ol><p>插入规则:</p><ol><li>2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</li><li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</li><li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</li><li><strong>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆仍然需要满足上面3个条件。</strong> </li><li>对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则</li></ol><h4 id="B树的介绍"><a href="#B树的介绍" class="headerlink" title="B树的介绍"></a>B树的介绍</h4><p>B-tree树即B树，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，B-tree就是指的B树。</p><p>前面已经介绍了2-3树和2-3-4树，他们就是B(Balance)树(英语：B-tree 也写成B-树)，这里我们再做一个说明，我们在学习Mysql时，经常听到说某种类型的索引是基于B树或者B+树的，如图:</p><p><img src="../../Users/juan/AppData/Roaming/Typora/typora-user-images/1672111258629.png" alt="1672111258629"></p><p>B树的说明:</p><ol><li>B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4</li><li>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</li><li>关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据.</li><li>搜索有可能在非叶子结点结束</li><li>其搜索性能等价于在关键字全集内做一次二分查找</li></ol><h4 id="B-树的介绍"><a href="#B-树的介绍" class="headerlink" title="B+树的介绍"></a>B+树的介绍</h4><p>B+树是B树的变体，也是一种多路搜索树。</p><p><img src="../../Users/juan/AppData/Roaming/Typora/typora-user-images/1672111568122.png" alt="1672111568122"></p><p>B+树的说明:</p><ol><li>B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</li><li><strong>所有关键字都出现在叶子结点的链表中</strong>（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。</li><li>不可能在非叶子结点命中</li><li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层<br>更适合文件索引系统</li><li>B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.</li></ol><h4 id="B-树的介绍-1"><a href="#B-树的介绍-1" class="headerlink" title="B*树的介绍"></a>B*树的介绍</h4><p>B<em>*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。B</em>树的说明:<br>B<em>树定义了非叶子结点关键字个数至少为(2/3)</em>M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。</p><p>从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高</p><p><img src="../../Users/juan/AppData/Roaming/Typora/typora-user-images/1672111854686.png" alt="1672111854686"></p><h2 id="图："><a href="#图：" class="headerlink" title="图："></a>图：</h2><h3 id="为什么要有图"><a href="#为什么要有图" class="headerlink" title="为什么要有图"></a>为什么要有图</h3><ol><li>线性表局限于一个直接前驱和一个直接后继的关系</li><li>树也只能有一个直接前驱也就是父节点</li><li>当我们需要表示多对多的关系时， 这里我们就用到了图</li></ol><p><strong>图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为顶点。</strong></p><p>图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。</p><p>邻接矩阵<br>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1….n个点。</p><p><img src="../../Users/juan/AppData/Roaming/Typora/typora-user-images/1672112751652.png" alt="1672112751652"></p><p>邻接表<br>邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失.<br>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成</p><p><img src="../../Users/juan/AppData/Roaming/Typora/typora-user-images/1672112727303.png" alt="1672112727303"></p><h3 id="图的构建："><a href="#图的构建：" class="headerlink" title="图的构建："></a>图的构建：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> grap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="comment">//vertex是顶点意思</span></span><br><span class="line">    <span class="comment">//edge在这里是边的意思</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;<span class="comment">//存储图对应的邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges;<span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=<span class="number">5</span>;<span class="comment">//节点的个数</span></span><br><span class="line">        String VertexValue[]=&#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (String value:VertexValue)&#123;</span><br><span class="line">            graph.insetVertex(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B,A-C,B-C,B-D,-B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//显示邻接矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器进行初始化</span></span><br><span class="line">    <span class="comment">//构造函数的作用是创建对象时，完成初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化矩阵和vertexList</span></span><br><span class="line">        edges=<span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//图中常用的方法</span></span><br><span class="line">    <span class="comment">//得到边的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] link:edges)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回节点i（下标）对应的数据 0 -&gt;&quot;A&quot;</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回v1和v2的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insetVertex</span><span class="params">(String vertex)</span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 表示点的下标，即第几个顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 表示路线的带权值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2,<span class="type">int</span> weight)</span>&#123;</span><br><span class="line">        edges[v1][v2]=weight;</span><br><span class="line">        edges[v2][v1]=weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="图遍历介绍"><a href="#图遍历介绍" class="headerlink" title="图遍历介绍"></a>图遍历介绍</h3><p>所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略: (1)深度优先遍历 (2)广度优先遍历</p><h4 id="图的深度优先搜索-Depth-First-Search-。"><a href="#图的深度优先搜索-Depth-First-Search-。" class="headerlink" title="图的深度优先搜索(Depth First Search) 。"></a>图的深度优先搜索(Depth First Search) 。</h4><p>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：<strong>每次都在访问完当前结点后首先访问当前结点的第一个邻接结点</strong>。<br>我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。<br>显然，<strong>深度优先搜索是一个递归的过程</strong></p><p><strong>深度优先遍历算法步骤</strong></p><ol><li>访问初始结点v，并标记结点v为已访问。</li><li>查找结点v的第一个邻接结点w。</li><li>若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。</li><li>若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。</li><li>查找结点v的w邻接结点的下一个邻接结点，转到步骤3。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> grap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="comment">//vertex是顶点意思</span></span><br><span class="line">    <span class="comment">//edge在这里是边的意思</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;<span class="comment">//存储图对应的邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges;<span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="comment">//定义一个数组boolean[],记录某个顶点是否被访问过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[]  isVisited;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=<span class="number">5</span>;<span class="comment">//节点的个数</span></span><br><span class="line">        String VertexValue[]=&#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (String value:VertexValue)&#123;</span><br><span class="line">            graph.insetVertex(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B,A-C,B-C,B-D,-B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//显示邻接矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line">        <span class="comment">//测试dfs</span></span><br><span class="line">        System.out.println(<span class="string">&quot;深度遍历&quot;</span>);</span><br><span class="line">        graph.dfs();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器进行初始化</span></span><br><span class="line">    <span class="comment">//构造函数的作用是创建对象时，完成初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化矩阵和vertexList</span></span><br><span class="line">        edges=<span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges=<span class="number">0</span>;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到第一个邻接节点的下标w</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果存在就返回对应的下标，否则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirstNeighbour</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;vertexList.size();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[index][j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据前一个邻接节点的下标来获取下一个邻接节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNeighbour</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=v2+<span class="number">1</span>;j&lt;vertexList.size();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v1][j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深度有限遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isVisited</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 第一次就是0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">boolean</span>[] isVisited,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="comment">//首先，我们访问该节点</span></span><br><span class="line">        System.out.println(getValueByIndex(i)+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//将节点设置已访问</span></span><br><span class="line">        isVisited[i]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//查找节点i的第一个邻接节点</span></span><br><span class="line">        <span class="type">int</span> w=getFirstNeighbour(i);</span><br><span class="line">        <span class="keyword">while</span> (w!=-<span class="number">1</span>)&#123;<span class="comment">//说明有邻接节点</span></span><br><span class="line">            <span class="keyword">if</span> (!isVisited[w])&#123;</span><br><span class="line">                dfs(isVisited,w);<span class="comment">//如果没有进行过访问，就继续</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果w节点已经被访问过了,就应该查找邻接点的下一个节点</span></span><br><span class="line">            w=getNextNeighbour(i,w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对dfs进行一个重载,遍历我们所有的节点，并进行dfs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//遍历所有的节点，并进行dfs</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;getNumOfVertex();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])&#123;</span><br><span class="line">                dfs(isVisited,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//图中常用的方法</span></span><br><span class="line">    <span class="comment">//得到边的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] link:edges)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回节点i（下标）对应的数据 0 -&gt;&quot;A&quot;</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回v1和v2的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insetVertex</span><span class="params">(String vertex)</span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 表示点的下标，即第几个顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 表示路线的带权值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2,<span class="type">int</span> weight)</span>&#123;</span><br><span class="line">        edges[v1][v2]=weight;</span><br><span class="line">        edges[v2][v1]=weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="图的广度优先搜索-Broad-First-Search-。"><a href="#图的广度优先搜索-Broad-First-Search-。" class="headerlink" title="图的广度优先搜索(Broad First Search) 。"></a>图的广度优先搜索(Broad First Search) 。</h4><p>类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</p><p><strong>广度优先遍历算法步骤</strong></p><ol><li>访问初始结点v并标记结点v为已访问。</li><li>结点v入队列</li><li>当队列非空时，继续执行，否则算法结束。</li><li>出队列，取得队头结点u。</li><li>查找结点u的第一个邻接结点w。</li><li>若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：<br>6.1 若结点w尚未被访问，则访问结点w并标记为已访问。<br>6.2 结点w入队列<br>6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">boolean</span>[] isVisited,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">int</span> u;<span class="comment">//表示队列头节点对应的下标</span></span><br><span class="line">        <span class="type">int</span> w;<span class="comment">//表示邻接节点w</span></span><br><span class="line">        <span class="comment">//队列,记录节点访问顺序</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="comment">//访问节点，输出节点的信息</span></span><br><span class="line">        System.out.print(getValueByIndex(i)+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//标记为已访问</span></span><br><span class="line">        isVisited[i]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//将节点加入队列</span></span><br><span class="line">        queue.addLast(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//取出队列的头节点下标</span></span><br><span class="line">            u=(Integer) queue.removeFirst();</span><br><span class="line">            <span class="comment">//得到第一个邻接点的下标</span></span><br><span class="line">            w= getFirstNeighbour(u);</span><br><span class="line">            <span class="keyword">while</span> (w!=-<span class="number">1</span>)&#123;<span class="comment">//是否访问过</span></span><br><span class="line">                <span class="keyword">if</span> (!isVisited[w])&#123;</span><br><span class="line">                    <span class="comment">//说明找到，可以连接</span></span><br><span class="line">                    System.out.print(getValueByIndex(w)+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                    <span class="comment">//下一步标记已经访问</span></span><br><span class="line">                    isVisited[w]=<span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//入队列</span></span><br><span class="line">                    queue.addLast(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//以u为前驱节点，找w后面的下一个邻接点</span></span><br><span class="line"></span><br><span class="line">                w=getNextNeighbour(u,w);<span class="comment">//体现出广度优先</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有的节点，都进行广度优先搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;getNumOfVertex();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])&#123;</span><br><span class="line">                bfs(isVisited,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法(四)</title>
      <link href="/2022/12/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%9B/"/>
      <url>/2022/12/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法-四"><a href="#数据结构与算法-四" class="headerlink" title="数据结构与算法(四)"></a>数据结构与算法(四)</h1><h2 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h2><h3 id="堆排序："><a href="#堆排序：" class="headerlink" title="堆排序："></a>堆排序：</h3><h4 id="小顶堆和大顶堆："><a href="#小顶堆和大顶堆：" class="headerlink" title="小顶堆和大顶堆："></a>小顶堆和大顶堆：</h4><p>堆排序基本介绍</p><ol><li><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p></li><li><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。</p></li><li><p>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆<br>大顶堆特点：arr[i] &gt;= arr[2<em>i+1] &amp;&amp; arr[i] &gt;= arr[2</em>i+2] </p><p>小顶堆：arr[i] &lt;= arr[2<em>i+1] &amp;&amp; arr[i] &lt;= arr[2</em>i+2]</p><p>一般升序采用大顶堆，降序采用小顶堆 </p></li></ol><p>堆排序的基本思想是：</p><ol><li>将待排序序列构造成一个大顶堆</li><li>此时，整个序列的最大值就是堆顶的根节点。</li><li>将其与末尾元素进行交换，此时末尾就为最大值。</li><li>然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//要求将数组进行升序排列</span></span><br><span class="line">        <span class="type">int</span>[] arr=&#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">66</span>,<span class="number">999</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编写一个堆排序的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> arr[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;堆排序&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i= arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            adjustHeap(arr,i, arr.length);</span><br><span class="line">        &#125;<span class="comment">//第一个for只是构建第一个最大堆</span></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i= arr.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            temp=arr[i];</span><br><span class="line">            arr[i]=arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>]=temp;<span class="comment">//这边是每次都将大顶堆中的最大值移到末尾，就不用考虑了</span></span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>, i);<span class="comment">//此处是将已经交换过数据的大顶堆继续改变后面的最大堆全部构建起来</span></span><br><span class="line">            <span class="comment">//此处填0是因为上面的循环已经将数调整好了，根节点以下也全是大顶堆了</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将一个数组(二叉树),调整成一个大顶堆</span></span><br><span class="line">    <span class="comment">//i表示非叶子节点在数组中的索引</span></span><br><span class="line">    <span class="comment">//length表示对多少个元素进行调整,逐渐减少</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> i,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="type">int</span> temp=arr[i];</span><br><span class="line">        <span class="comment">//k=i*2+1是i节点的左子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((k+<span class="number">1</span>)&lt;length &amp;&amp;arr[k]&lt;arr[k+<span class="number">1</span>])&#123;<span class="comment">//左子节点比右子节点小</span></span><br><span class="line">                k++;<span class="comment">// k指向右子节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[k]&gt;temp)&#123;<span class="comment">//如果子节点大于父节点</span></span><br><span class="line">                arr[i]=arr[k];</span><br><span class="line">                i=k;<span class="comment">//i指向k，继续循环比较</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for循环结束后，我们已经将i为父节点的树的最大值，放在了最顶上</span></span><br><span class="line">        arr[i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="赫夫曼树："><a href="#赫夫曼树：" class="headerlink" title="赫夫曼树："></a>赫夫曼树：</h2><p>基本介绍</p><ol><li>给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。</li><li>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</li><li>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1</li><li>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积</li><li>树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length) ,<strong>权值越大的结点离根结点越近的二叉树才是最优二叉树</strong>。</li><li><strong>WPL最小的就是赫夫曼树</strong></li></ol><p><strong>构成赫夫曼树的步骤：</strong></p><ol><li>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树<br>取出根节点权值最小的两颗二叉树 </li><li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和  </li><li>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复  1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Huffman;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr=&#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">29</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        preOrder(createHuffmanTree(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编写一个前序遍历的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            root.PreOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空树&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写下创建赫夫曼树的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="comment">//第一步为了操作方便</span></span><br><span class="line">        <span class="comment">//1.遍历arr数组</span></span><br><span class="line">        <span class="comment">//2.将arr每个元素构成一个Node</span></span><br><span class="line">        <span class="comment">//3.将Node放入ArrayList中</span></span><br><span class="line">        ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//先排序,从小到大</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            <span class="comment">//取出根节点权值最小的两颗二叉树节点</span></span><br><span class="line">            <span class="comment">//1.取出权值最小的节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//2.取出第二小的节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//3.构建一颗新的二叉树</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(leftNode.value + rightNode.value);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.从ArrayList中，删除处理过的二叉树</span></span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            <span class="comment">//5.将parent加入到nodes中</span></span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建节点类</span></span><br><span class="line"><span class="comment">//为了让Node实现Collections集合排序</span></span><br><span class="line"><span class="comment">//让Node实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt;&#123;</span><br><span class="line">    <span class="type">int</span> value;<span class="comment">//结点权值</span></span><br><span class="line">    Node left;<span class="comment">//指向左子节点</span></span><br><span class="line">    Node right;<span class="comment">//指向右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="comment">//TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value - o.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写一个前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PreOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.PreOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.PreOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="赫夫曼编码："><a href="#赫夫曼编码：" class="headerlink" title="赫夫曼编码："></a>赫夫曼编码：</h2><ol><li>赫夫曼编码也翻译为    哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法<br>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</li><li>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间<br>赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码</li></ol><p>//根据赫夫曼树，给各个字符<br>//规定编码 ， 向左的路径为0<br>//向右的路径为1 ， 编码如下:</p><p>o: 1000   u: 10010  d: 100110  y: 100111  i: 101<br>a : 110     k: 1110    e: 1111       j: 0000       v: 0001<br>l: 001          : 01</p><p>按照上面的赫夫曼编码，我们的”i like like like java do you like a java”   字符串对应的编码为 (注意这里我们使用的无损压缩)</p><p>1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110</p><p>长度为 ： 133<br>说明:<br>原来长度是  359 , 压缩了  (359-133) / 359 = 62.9%<br>此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性</p><p><strong>传输的 字符串</strong><br>1) i like like like java do you like a java    </p><p>2)  d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9  // 各个字符对应的个数</p><p>3)  按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值 </p><p><strong>步骤：</strong><br>构成赫夫曼树的步骤：<br>1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树<br>2) 取出根节点权值最小的两颗二叉树<br>3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和<br>4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复  1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</p><p><strong>5)  根据赫夫曼树，给各个字符,规定编码 (前缀编码)， 向左的路径为0 向右的路径为1 ， 编码如下:</strong><br><strong>o: 1000   u: 10010  d: 100110  y: 100111  i: 101</strong><br><strong>a : 110     k: 1110    e: 1111       j: 0000       v: 0001</strong><br><strong>l: 001          : 01</strong></p><p><strong>6) 按照上面的赫夫曼编码，我们的”i like like like java do you like a java”   字符串对应的编码为 (注意这里我们使用的无损压缩)</strong><br><strong>1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110  通过赫夫曼编码处理  长度为  133</strong></p><p><strong>注意, 这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是wpl 是一样的，都是最小的</strong></p><h3 id="最佳实践-数据压缩-创建赫夫曼树"><a href="#最佳实践-数据压缩-创建赫夫曼树" class="headerlink" title="最佳实践-数据压缩(创建赫夫曼树)"></a>最佳实践-数据压缩(创建赫夫曼树)</h3><p>功能： 根据赫夫曼编码压缩数据的原理，需要创建 “i like like like java do you like a java” 对应的赫夫曼树</p><p>思路:<br>(1) Node { data (存放数据)， weight (权值)， left  和 right }<br>(2) 得到  “i like like like java do you like a java”   对应的 byte[] 数组<br>(3)  编写一个方法，将准备构建赫夫曼树的Node 节点放到 List  , 形式 [Node[date=97 ,weight = 5], Node[]date=32,weight = 9]……],  体现 d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9<br>(4) 可以通过List 创建对应的赫夫曼树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Huffman;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String content=<span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] contentBytes = content.getBytes();</span><br><span class="line">        List&lt;Nod&gt; nodes = getNodes(contentBytes);</span><br><span class="line">        System.out.println(nodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试创建的二叉树</span></span><br><span class="line">        System.out.println(<span class="string">&quot;赫夫曼树：&quot;</span>);</span><br><span class="line">        <span class="type">Nod</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        preOrder(huffmanTreeRoot);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试是否产生了哈夫曼编码</span></span><br><span class="line">        getCodes(huffmanTreeRoot,<span class="string">&quot;&quot;</span>,stringBuilder);</span><br><span class="line">        System.out.println(<span class="string">&quot;生成的哈夫曼编码表 &quot;</span>+huffmanCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = zip(contentBytes, huffmanCodes);</span><br><span class="line">        System.out.println(<span class="string">&quot;huffmanCodeBytes=&quot;</span>+Arrays.toString(huffmanCodeBytes));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，将一个字符串对应的byte[]数组，通过生成的赫夫曼编码表，返回赫夫曼编码压缩后的byte[]</span></span><br><span class="line">    <span class="comment">//byte为原始的字符串对应的数组</span></span><br><span class="line">    <span class="comment">//huffmanCodes为生成的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//需要返回一个赫夫曼编码处理后的byte[]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes,Map&lt;Byte,String&gt; huffmanCodes)&#123;</span><br><span class="line">        <span class="comment">//1.先利用赫夫曼编码表，将传进来的bytes转成赫夫曼编码对应的字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">//遍历byte数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b:bytes)&#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));<span class="comment">//能够产生0，1组成的编码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将对应长度133的字符串转换成byte[]</span></span><br><span class="line">        <span class="comment">//统计返回byte[]，huffmanCodeBytes长度</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length()%<span class="number">8</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            len=stringBuilder.length()/<span class="number">8</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            len=stringBuilder.length()/<span class="number">8</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个存储压缩后的byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;<span class="comment">//记录第几个byte</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;stringBuilder.length();i+=<span class="number">8</span>)&#123;<span class="comment">//因为每八位对应一个byte，所以我们的步长每次要加8</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">8</span>&gt;stringBuilder.length())&#123;<span class="comment">//防止数组越界</span></span><br><span class="line">                <span class="comment">//说明不够8位</span></span><br><span class="line">                strByte=stringBuilder.substring(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                strByte=stringBuilder.substring(i,i+<span class="number">8</span>);<span class="comment">//每循环一次，取8位</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//j+将strByte转成一个byte，放入到by</span></span><br><span class="line">            huffmanCodeBytes[index]=(<span class="type">byte</span>) Integer.parseInt(strByte);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产哈夫曼树对应的哈夫曼编码</span></span><br><span class="line">    <span class="comment">//1.将赫夫曼编码表存放在该map中</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte,String&gt; huffmanCodes=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2.在生产赫夫曼编码表示，需要取拼接路径，定义一个StringBuilder存储某个叶子节点的路径</span></span><br><span class="line">    <span class="keyword">static</span> StringBuilder stringBuilder=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">//生成赫夫曼编码</span></span><br><span class="line">    <span class="comment">//node:传入节点</span></span><br><span class="line">    <span class="comment">//code：路径：左子节点是0，右子节点是1</span></span><br><span class="line">    <span class="comment">//stringBuilder 适用于拼接路径的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Nod node,String code,StringBuilder stringBuilder)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">        <span class="comment">//将传入的code加入到stringBuilder2</span></span><br><span class="line">        stringBuilder2.append(code);</span><br><span class="line">            <span class="keyword">if</span> (node!=<span class="literal">null</span>)&#123;<span class="comment">//node为空，不处理</span></span><br><span class="line">                <span class="comment">//判断当前node是叶子节点还是非叶子节点</span></span><br><span class="line">                <span class="keyword">if</span> (node.data==<span class="literal">null</span>)&#123;<span class="comment">//说明是非叶子节点</span></span><br><span class="line">                    <span class="comment">//递归处理</span></span><br><span class="line">                    <span class="comment">//向左递归</span></span><br><span class="line">                    getCodes(node.left,<span class="string">&quot;0&quot;</span>,stringBuilder2);</span><br><span class="line">                    <span class="comment">//向右递归</span></span><br><span class="line">                    getCodes(node.right,<span class="string">&quot;1&quot;</span>,stringBuilder2);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;<span class="comment">//说明是一个叶子节点</span></span><br><span class="line">                    <span class="comment">//表示找到了某个叶子节点的最后</span></span><br><span class="line">                    huffmanCodes.put(node.data,stringBuilder2.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Nod root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            root.PreOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空树&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受的是Bytes数组</span></span><br><span class="line">    <span class="comment">//返回的是List形式的[Node[date=97 ,weight = 5], Node[]date=32,weight = 9]......],</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Nod&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个ArrayList</span></span><br><span class="line">        ArrayList&lt;Nod&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.遍历Bytes，统计存储每个Byte出现的次数-&gt;map</span></span><br><span class="line">        HashMap&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b:bytes)&#123;</span><br><span class="line">            Integer count= counts.get(b);</span><br><span class="line">            <span class="keyword">if</span> (count==<span class="literal">null</span>)&#123;</span><br><span class="line">                counts.put(b,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                counts.put(b,count+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把每个键值对改成一个Node对象，并加入到node集合</span></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte,Integer&gt; entry: counts.entrySet())&#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Nod</span>(entry.getKey(),entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过List创建对应的赫夫曼树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Nod <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Nod&gt; nodes)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            Collections.sort(nodes);<span class="comment">//从小到大排</span></span><br><span class="line">            <span class="comment">//取出第一颗最小的二叉树</span></span><br><span class="line">            <span class="type">Nod</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//取出第二课最小的二叉树</span></span><br><span class="line">            <span class="type">Nod</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//创建一颗新的二叉树,他的根节点没有data，只有权值</span></span><br><span class="line">            <span class="type">Nod</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Nod</span>(<span class="literal">null</span>, leftNode.weight+ rightNode.weight);</span><br><span class="line">            parent.left=leftNode;</span><br><span class="line">            parent.right=rightNode;</span><br><span class="line">            <span class="comment">//将已经处理过的两颗二叉树溢出</span></span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            <span class="comment">//将新的二叉树加入到nodes中</span></span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回的节点就是哈夫曼树的根节点</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建Node，带有数据和权值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Nod</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Nod&gt;&#123;</span><br><span class="line">    Byte data;<span class="comment">//存放数据本身,例如&#x27;a&#x27;-&gt;97</span></span><br><span class="line">    <span class="type">int</span> weight;<span class="comment">//权值，表示上面的字符出现的次数</span></span><br><span class="line">    Nod left;</span><br><span class="line">    Nod right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Nod</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//comparable中自带的排序方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Nod o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight-o.weight;<span class="comment">//表示从小到大排序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Nod&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PreOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.PreOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.PreOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数据解压："><a href="#数据解压：" class="headerlink" title="数据解压："></a>数据解压：</h3><p>数据解压这块，由于写者没有看到很好的思路，<del>自己也不会，就暂时不写了，以后补上</del>。</p><h2 id="二叉排序树："><a href="#二叉排序树：" class="headerlink" title="二叉排序树："></a>二叉排序树：</h2><p>二叉排序树介绍</p><p>二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。<br>特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点</p><h3 id="二叉排序树的创建和遍历："><a href="#二叉排序树的创建和遍历：" class="headerlink" title="二叉排序树的创建和遍历："></a>二叉排序树的创建和遍历：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BinarySortTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySortTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr=&#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">BinarySortTree1</span> <span class="variable">binarySortTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySortTree1</span>();</span><br><span class="line">        <span class="comment">//循环的添加节点到二叉排序树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; arr.length;i++)&#123;</span><br><span class="line">            binarySortTree.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中序遍历二叉排序树</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历二叉排序树&quot;</span>);</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySortTree1</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">//添加节点的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="comment">//判断是否是空</span></span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            root=node;<span class="comment">//如果root为空，则让root指向node</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉排序树为空，不能遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建node节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">     <span class="type">int</span> value;</span><br><span class="line">     Node left;</span><br><span class="line">     Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//toString方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要一个添加节点的方法</span></span><br><span class="line">    <span class="comment">//递归的形式添加节点，需要满足二叉排序树的要求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断，传入节点的值，和当前节点的</span></span><br><span class="line">        <span class="keyword">if</span> (node.value&lt;<span class="built_in">this</span>.value)&#123;</span><br><span class="line">            <span class="comment">//如果当前子树左子节点为null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.left=node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//不为null，则向左递归</span></span><br><span class="line">                <span class="built_in">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//添加节点的值大于当前节点的值</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.right=node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉排序树的删除："><a href="#二叉排序树的删除：" class="headerlink" title="二叉排序树的删除："></a>二叉排序树的删除：</h3><p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑</p><p>删除叶子节点<br>删除只有一颗子树的节点<br>删除有两颗子树的节点. </p><h4 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况:"></a>第一种情况:</h4><p>删除叶子节点 (比如：2, 5, 9, 12)<br>思路<br>(1) 需求先去找到要删除的结点  targetNode<br>(2)  找到targetNode 的 父结点 parent<br>(3)  确定 targetNode 是 parent的左子结点 还是右子结点<br>(4)  根据前面的情况来对应删除<br>左子结点 parent.left = null<br>右子结点 parent.right = null;</p><p><strong>node节点：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line">   <span class="comment">//value是我希望查找的值</span></span><br><span class="line">   <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (value==<span class="built_in">this</span>.value)&#123;</span><br><span class="line">           <span class="comment">//说明找到，就是该节点</span></span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value&lt;<span class="built_in">this</span>.value) &#123;<span class="comment">//如果查找的值小于当前节点，向左子树递归</span></span><br><span class="line">           <span class="comment">//如果左子节点还为空</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">this</span>.left==<span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>.left.search(value);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果查找到值不小于当前节点，向右子树递归</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">this</span>.right==<span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>.right.search(value);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//查找要删除节点的父节点</span></span><br><span class="line">   <span class="comment">//value是要查找的结点的值</span></span><br><span class="line">   <span class="comment">//返回的是要删除的节点的父节点,没有，返回null</span></span><br><span class="line">   <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">       <span class="comment">//如果当前节点就是要删除的节点的父节点，就返回</span></span><br><span class="line">       <span class="keyword">if</span> ((<span class="built_in">this</span>.left!=<span class="literal">null</span>&amp;&amp;<span class="built_in">this</span>.left.value==value)||(<span class="built_in">this</span>.right!=<span class="literal">null</span>&amp;&amp;<span class="built_in">this</span>.right.value==value))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//如果要查找的这个值小于当前节点的值，并且当前节点的左子节点不为空</span></span><br><span class="line">           <span class="keyword">if</span> (value&lt;<span class="built_in">this</span>.value&amp;&amp;<span class="built_in">this</span>.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">this</span>.left.searchParent(value);<span class="comment">//向左子树递归查找</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value&gt;=<span class="built_in">this</span>.value&amp;&amp;<span class="built_in">this</span>.right!=<span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="built_in">this</span>.right.searchParent(value);<span class="comment">//向右子树递归查找</span></span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//没有找到父节点</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>List节点：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除节点的父节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除叶节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//(1) 需求先去找到要删除的结点  targetNode</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">targetNode</span> <span class="operator">=</span> search(value);</span><br><span class="line">            <span class="comment">//如果没有找到要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果我们发现当前这个二叉排序树只有一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                root=<span class="literal">null</span>;<span class="comment">//置空且返回</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//(2)  找到targetNode 的 父结点 parent</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> searchParent(value);</span><br><span class="line">            <span class="comment">//如果要删除的节点是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode.left==<span class="literal">null</span>&amp;&amp;targetNode.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//确定targetNode 的子结点是左子结点还是右子结点</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left!=<span class="literal">null</span>&amp;&amp;parent.left.value==value)&#123;</span><br><span class="line">                    parent.left=<span class="literal">null</span>;<span class="comment">//是左子节点</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right!=<span class="literal">null</span>&amp;&amp;parent.right.value==value) &#123;</span><br><span class="line">                    <span class="comment">//是右子节点</span></span><br><span class="line">                    parent.right=<span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况:"></a><strong>第二种情况:</strong></h4><p>删除只有一颗子树的节点 比如 1<br>思路<br>(1) 需求先去找到要删除的结点  targetNode<br>(2)  找到targetNode 的 父结点 parent<br>(3) 确定targetNode 的子结点是左子结点还是右子结点<br>(4) targetNode 是 parent 的左子结点还是右子结点<br>(5) 如果targetNode 有左子结点</p><ol><li>1 如果 targetNode 是 parent 的左子结点<br>parent.left = targetNode.left;<br>5.2  如果 targetNode 是 parent 的右子结点<br>parent.right = targetNode.left;<br>(6) 如果targetNode 有右子结点<br>6.1 如果 targetNode 是 parent 的左子结点<br>parent.left = targetNode.right;<br>6.2 如果 targetNode 是 parent 的右子结点<br>parent.right = targetNode.right</li></ol><p><strong>node节点：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line">   <span class="comment">//value是我希望查找的值</span></span><br><span class="line">   <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (value==<span class="built_in">this</span>.value)&#123;</span><br><span class="line">           <span class="comment">//说明找到，就是该节点</span></span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value&lt;<span class="built_in">this</span>.value) &#123;<span class="comment">//如果查找的值小于当前节点，向左子树递归</span></span><br><span class="line">           <span class="comment">//如果左子节点还为空</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">this</span>.left==<span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>.left.search(value);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果查找到值不小于当前节点，向右子树递归</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">this</span>.right==<span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>.right.search(value);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//查找要删除节点的父节点</span></span><br><span class="line">   <span class="comment">//value是要查找的结点的值</span></span><br><span class="line">   <span class="comment">//返回的是要删除的节点的父节点,没有，返回null</span></span><br><span class="line">   <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">       <span class="comment">//如果当前节点就是要删除的节点的父节点，就返回</span></span><br><span class="line">       <span class="keyword">if</span> ((<span class="built_in">this</span>.left!=<span class="literal">null</span>&amp;&amp;<span class="built_in">this</span>.left.value==value)||(<span class="built_in">this</span>.right!=<span class="literal">null</span>&amp;&amp;<span class="built_in">this</span>.right.value==value))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//如果要查找的这个值小于当前节点的值，并且当前节点的左子节点不为空</span></span><br><span class="line">           <span class="keyword">if</span> (value&lt;<span class="built_in">this</span>.value&amp;&amp;<span class="built_in">this</span>.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">this</span>.left.searchParent(value);<span class="comment">//向左子树递归查找</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value&gt;=<span class="built_in">this</span>.value&amp;&amp;<span class="built_in">this</span>.right!=<span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="built_in">this</span>.right.searchParent(value);<span class="comment">//向右子树递归查找</span></span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//没有找到父节点</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>List中方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(2)  找到targetNode 的 父结点 parent</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> searchParent(value);</span><br><span class="line">            <span class="comment">//如果要删除的节点是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode.left==<span class="literal">null</span>&amp;&amp;targetNode.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//确定targetNode 的子结点是左子结点还是右子结点</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left!=<span class="literal">null</span>&amp;&amp;parent.left.value==value)&#123;</span><br><span class="line">                    parent.left=<span class="literal">null</span>;<span class="comment">//是左子节点</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right!=<span class="literal">null</span>&amp;&amp;parent.right.value==value) &#123;</span><br><span class="line">                    <span class="comment">//是右子节点</span></span><br><span class="line">                    parent.right=<span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left!=<span class="literal">null</span>&amp;&amp;targetNode.right!=<span class="literal">null</span>) &#123;<span class="comment">//删除有两颗子树的情况</span></span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//删除只有一颗子树的情况</span></span><br><span class="line">                <span class="comment">//如果要删除的节点有左子节点</span></span><br><span class="line">                <span class="keyword">if</span> (targetNode.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line">                    <span class="keyword">if</span> (parent.left.value==value)&#123;</span><br><span class="line">                        parent.left=targetNode.left;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//说明是parent的右子节点</span></span><br><span class="line">                        parent.right=targetNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果要删除的节点有右子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (parent.left.value==value)&#123;</span><br><span class="line">                        parent.left=targetNode.right;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        parent.right=targetNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="第三种情况："><a href="#第三种情况：" class="headerlink" title="第三种情况："></a>第三种情况：</h4><p>： 删除有两颗子树的节点. (比如：7, 3，10 )<br>思路<br>(1) 需求先去找到要删除的结点  targetNode<br>(2)  找到targetNode 的 父结点 parent<br>(3)  从targetNode 的右子树找到最小的结点<br>(4) 用一个临时变量，将 最小结点的值保存 temp = 11<br>(5)  删除该最小结点<br>(6)  targetNode.value = temp</p><h4 id="完整版："><a href="#完整版：" class="headerlink" title="完整版："></a>完整版：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BinarySortTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySortTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr=&#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="type">BinarySortTree1</span> <span class="variable">binarySortTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySortTree1</span>();</span><br><span class="line">        <span class="comment">//循环的添加节点到二叉排序树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; arr.length;i++)&#123;</span><br><span class="line">            binarySortTree.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中序遍历二叉排序树</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历二叉排序树&quot;</span>);</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //删除节点</span></span><br><span class="line"><span class="comment">//        binarySortTree.delNode(2);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;删除节点后&quot;);</span></span><br><span class="line"><span class="comment">//        binarySortTree.infixOrder();</span></span><br><span class="line"><span class="comment">//        //删除节点</span></span><br><span class="line"><span class="comment">//       binarySortTree.delNode(1);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;删除节点后&quot;);</span></span><br><span class="line"><span class="comment">//        binarySortTree.infixOrder();</span></span><br><span class="line">        <span class="comment">//删除节点</span></span><br><span class="line">       binarySortTree.delNode(<span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除节点后&quot;</span>);</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySortTree1</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除的节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除节点的父节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写方法</span></span><br><span class="line">    <span class="comment">//1. 返回以node为根节点的二叉排序树的最小节点的值</span></span><br><span class="line">    <span class="comment">//2. 删除node为根节点的二叉排序树的最小节点</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的节点(当作二叉排序树的根节点)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的是一node为根节点的二叉排序树的最小节点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delRightTreeMin</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        Node target=node;</span><br><span class="line">        <span class="comment">//循环查找左节点，就会找到最小值</span></span><br><span class="line">        <span class="keyword">while</span> (target.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            target=target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这时target就指向了最小节点</span></span><br><span class="line">        <span class="comment">//删除最小节点</span></span><br><span class="line">        delNode(target.value);</span><br><span class="line">        <span class="comment">//返回最小节点的值</span></span><br><span class="line">        <span class="keyword">return</span> target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除叶节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//(1) 需求先去找到要删除的结点  targetNode</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">targetNode</span> <span class="operator">=</span> search(value);</span><br><span class="line">            <span class="comment">//如果没有找到要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果我们发现当前这个二叉排序树只有一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                root=<span class="literal">null</span>;<span class="comment">//置空且返回</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//(2)  找到targetNode 的 父结点 parent</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> searchParent(value);</span><br><span class="line">            <span class="comment">//如果要删除的节点是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode.left==<span class="literal">null</span>&amp;&amp;targetNode.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//确定targetNode 的子结点是左子结点还是右子结点</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left!=<span class="literal">null</span>&amp;&amp;parent.left.value==value)&#123;</span><br><span class="line">                    parent.left=<span class="literal">null</span>;<span class="comment">//是左子节点</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right!=<span class="literal">null</span>&amp;&amp;parent.right.value==value) &#123;</span><br><span class="line">                    <span class="comment">//是右子节点</span></span><br><span class="line">                    parent.right=<span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left!=<span class="literal">null</span>&amp;&amp;targetNode.right!=<span class="literal">null</span>) &#123;<span class="comment">//删除有两颗子树的情况</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">minVal</span> <span class="operator">=</span> delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.value=minVal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//删除只有一颗子树的情况</span></span><br><span class="line">                <span class="comment">//如果要删除的节点有左子节点</span></span><br><span class="line">                <span class="keyword">if</span> (targetNode.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line">                    <span class="keyword">if</span> (parent.left.value==value)&#123;</span><br><span class="line">                        parent.left=targetNode.left;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//说明是parent的右子节点</span></span><br><span class="line">                        parent.right=targetNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果要删除的节点有右子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (parent.left.value==value)&#123;</span><br><span class="line">                        parent.left=targetNode.right;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        parent.right=targetNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="comment">//判断是否是空</span></span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            root=node;<span class="comment">//如果root为空，则让root指向node</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉排序树为空，不能遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建node节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">     <span class="type">int</span> value;</span><br><span class="line">     Node left;</span><br><span class="line">     Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找要删除的节点</span></span><br><span class="line">    <span class="comment">//value是我希望查找的值</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value==<span class="built_in">this</span>.value)&#123;</span><br><span class="line">            <span class="comment">//说明找到，就是该节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value&lt;<span class="built_in">this</span>.value) &#123;<span class="comment">//如果查找的值小于当前节点，向左子树递归</span></span><br><span class="line">            <span class="comment">//如果左子节点还为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.left.search(value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果查找到值不小于当前节点，向右子树递归</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找要删除节点的父节点</span></span><br><span class="line">    <span class="comment">//value是要查找的结点的值</span></span><br><span class="line">    <span class="comment">//返回的是要删除的节点的父节点,没有，返回null</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="comment">//如果当前节点就是要删除的节点的父节点，就返回</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">this</span>.left!=<span class="literal">null</span>&amp;&amp;<span class="built_in">this</span>.left.value==value)||(<span class="built_in">this</span>.right!=<span class="literal">null</span>&amp;&amp;<span class="built_in">this</span>.right.value==value))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果要查找的这个值小于当前节点的值，并且当前节点的左子节点不为空</span></span><br><span class="line">            <span class="keyword">if</span> (value&lt;<span class="built_in">this</span>.value&amp;&amp;<span class="built_in">this</span>.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="built_in">this</span>.left.searchParent(value);<span class="comment">//向左子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value&gt;=<span class="built_in">this</span>.value&amp;&amp;<span class="built_in">this</span>.right!=<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.right.searchParent(value);<span class="comment">//向右子树递归查找</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//没有找到父节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//toString方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要一个添加节点的方法</span></span><br><span class="line">    <span class="comment">//递归的形式添加节点，需要满足二叉排序树的要求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断，传入节点的值，和当前节点的</span></span><br><span class="line">        <span class="keyword">if</span> (node.value&lt;<span class="built_in">this</span>.value)&#123;</span><br><span class="line">            <span class="comment">//如果当前子树左子节点为null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.left=node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//不为null，则向左递归</span></span><br><span class="line">                <span class="built_in">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//添加节点的值大于当前节点的值</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.right=node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平衡二叉树-AVL-："><a href="#平衡二叉树-AVL-：" class="headerlink" title="平衡二叉树(AVL)："></a>平衡二叉树(AVL)：</h2><p>基本介绍</p><ol><li>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高。</li><li>具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</li><li>平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。</li></ol><h3 id="AVL的高度求解："><a href="#AVL的高度求解：" class="headerlink" title="AVL的高度求解："></a>AVL的高度求解：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leftHeight</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.height();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回右子树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rightHright</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回以该节点为根节点的树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left==<span class="literal">null</span>?<span class="number">0</span>:left.height(),right==<span class="literal">null</span>?<span class="number">0</span>: right.height())+<span class="number">1</span>;<span class="comment">//本身节点要算一层，要加1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="左旋转方法："><a href="#左旋转方法：" class="headerlink" title="左旋转方法："></a>左旋转方法：</h3><p>目的：降低右子树的高度</p><p><strong>1.创建一个新的系欸但newNode，值等于当前节点的值。</strong></p><p><strong>//把新节点的左子树设置为当前节点的左子树</strong></p><p><strong>2.newNode.left=left</strong></p><p><strong>//把当前节点的右子树设置为当前节点的右子树的左子树</strong></p><p><strong>3.newNode.right=right.left</strong></p><p><strong>//把当前节点的值换为右子节点的值</strong></p><p><strong>4.value=right.value</strong></p><p><strong>//把当前节点的右子树设置成右子树的右子树</strong></p><p><strong>5.right=right.right</strong></p><p><strong>//把当前节点的左子树设置为新节点</strong></p><p><strong>6.left=newleft</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> AVL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AvLTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr=&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="comment">//创建一个AVLtree对象</span></span><br><span class="line">        <span class="type">AvlTree</span> <span class="variable">avlTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AvlTree</span>();</span><br><span class="line">        <span class="comment">//添加节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; arr.length;i++)&#123;</span><br><span class="line">            avlTree.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">        avlTree.infixOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;在没有平衡处理后&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;树的高度：&quot;</span>+avlTree.getRoot().height());</span><br><span class="line">        System.out.println(<span class="string">&quot;树的左子树的高度：&quot;</span>+avlTree.getRoot().leftHeight());</span><br><span class="line">        System.out.println(<span class="string">&quot;树的右子树的高度：&quot;</span>+avlTree.getRoot().rightHright());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AvlTree</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="comment">//判断是否是空</span></span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            root=node;<span class="comment">//如果root为空，则让root指向node</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉排序树为空，不能遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回左子树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leftHeight</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.height();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回右子树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rightHright</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回以该节点为根节点的树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left==<span class="literal">null</span>?<span class="number">0</span>:left.height(),right==<span class="literal">null</span>?<span class="number">0</span>: right.height())+<span class="number">1</span>;<span class="comment">//本身节点要算一层，要加1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左旋转的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//创建新的节点，以当前根节点的值来创建</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        <span class="comment">//把新的节点的左子树设置成当前节点的左子树</span></span><br><span class="line">        newNode.left=left;</span><br><span class="line">        <span class="comment">//把新的节点的右子树设置成当前节点的右子树的左子树</span></span><br><span class="line">        newNode.right=right.left;</span><br><span class="line">        <span class="comment">//把当前节点的值替换成右子结点的值</span></span><br><span class="line">        value=right.value;</span><br><span class="line">        <span class="comment">//把当前节点的右子树，设置成右子树的右子树</span></span><br><span class="line">        right=right.right;</span><br><span class="line">        <span class="comment">//把当前节点的左子树（左子节点）设置成新的节点</span></span><br><span class="line">        left=newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//toString方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要一个添加节点的方法</span></span><br><span class="line">    <span class="comment">//递归的形式添加节点，需要满足二叉排序树的要求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断，传入节点的值，和当前节点的</span></span><br><span class="line">        <span class="keyword">if</span> (node.value&lt;<span class="built_in">this</span>.value)&#123;</span><br><span class="line">            <span class="comment">//如果当前子树左子节点为null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.left=node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//不为null，则向左递归</span></span><br><span class="line">                <span class="built_in">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//添加节点的值大于当前节点的值</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.right=node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行判断</span></span><br><span class="line">        <span class="comment">//当添加完一个节点后，如果:(右子树的高度-左子树的高度)&gt;1，左旋转</span></span><br><span class="line">        <span class="keyword">if</span> (rightHright()-leftHeight()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//进行旋转</span></span><br><span class="line">           leftRotate();<span class="comment">//左旋转</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="右旋转方法："><a href="#右旋转方法：" class="headerlink" title="右旋转方法："></a>右旋转方法：</h3><p>目的：降低左子树的高度</p><p><strong>1.创建一个新的节点newNode,值等于当前节点的值</strong></p><p><strong>//把新节点的右子树设置成当前节点的右子树</strong></p><p><strong>2.newNode.right=right</strong></p><p><strong>//把新节点的左子树设置成当前节点的左子树的右子树</strong></p><p><strong>3.newNode.left=left.right</strong></p><p><strong>//把当前节点的值换成左子树的值</strong></p><p><strong>4.value=left.value</strong></p><p><strong>//把当前节点的左子树设置成左子树的左子树</strong></p><p><strong>5.left=left.left</strong></p><p><strong>//把当前节点的右子树设置成新节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        newNode.right=right;</span><br><span class="line">        newNode.left=left.right;</span><br><span class="line">        value=left.value;</span><br><span class="line">        left=left.left;</span><br><span class="line">        right=newNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="双旋转方法："><a href="#双旋转方法：" class="headerlink" title="双旋转方法："></a>双旋转方法：</h3><p>当单次旋转无法完成任务的时候，使用双旋转</p><ol><li>当符号右旋转的条件时</li><li>如果它的左子树的右子树高度大于它的左子树的左子树的高度</li><li>先对当前这个结点的左节点进行左旋转</li><li>再对当前结点进行右旋转的操作即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行判断</span></span><br><span class="line">        <span class="comment">//当添加完一个节点后，如果:(右子树的高度-左子树的高度)&gt;1，左旋转</span></span><br><span class="line">        <span class="keyword">if</span> (rightHright()-leftHeight()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="comment">//如果它的右子树的左子树的高度大于它的右子树的右子树的高度</span></span><br><span class="line">            <span class="keyword">if</span> (right!=<span class="literal">null</span>&amp;&amp;right.leftHeight()&gt;right.rightHright())&#123;</span><br><span class="line">                <span class="comment">//先进行右旋转，再进行左旋转，先对右子节点进行右旋转</span></span><br><span class="line">                right.rightRotate();</span><br><span class="line">                <span class="comment">//再对当前节点进行左旋转</span></span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当添加完一个节点后，如果:(左子树的高度-右子树的高度)&gt;1</span></span><br><span class="line">        <span class="keyword">if</span> (leftHeight()-rightHright()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//如果他的左子树的右子树的高度大于他的左子树的左子树的高度</span></span><br><span class="line">            <span class="keyword">if</span> (left!=<span class="literal">null</span>&amp;&amp;left.rightHright()&gt;left.leftHeight())&#123;</span><br><span class="line">                <span class="comment">//先对当前节点的左节点进行左旋转</span></span><br><span class="line">                left.leftRotate();</span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//直接进行右旋转即可</span></span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ASCII码一览表，ASCII码对照表</title>
      <link href="/2022/12/27/ASCII%E7%A0%81%E4%B8%80%E8%A7%88%E8%A1%A8%EF%BC%8CASCII%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8/"/>
      <url>/2022/12/27/ASCII%E7%A0%81%E4%B8%80%E8%A7%88%E8%A1%A8%EF%BC%8CASCII%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="ASCII码一览表，ASCII码对照表"><a href="#ASCII码一览表，ASCII码对照表" class="headerlink" title="ASCII码一览表，ASCII码对照表"></a>ASCII码一览表，ASCII码对照表</h1><p> ASCII（American Standard Code for Information Interchange，美国信息互换标准代码）是一套基于拉丁字母的字符编码，共收录了 128 个字符，用一个字节就可以存储，它等同于国际标准 ISO/IEC 646。</p><p>ASCII 编码于 1967 年第一次发布，最后一次更新是在 1986 年，迄今为止共收录了 128 个字符，包含了基本的拉丁字母（英文字母）、阿拉伯数字（也就是 1234567890）、标点符号（,.!等）、特殊符号（@#$%^&amp;等）以及一些具有控制功能的字符（往往不会显示出来）。</p><p>ASCII 编码是美国人给自己设计的，他们并没有考虑欧洲那些扩展的拉丁字母，也没有考虑韩语和日语，我大中华几万个汉字更是不可能被重视。计算机也是美国人发明的，起初使用的就是 ASCII 码，只能显示英文字符。各个国家为了让本国公民也能正常使用计算机，开始效仿 ASCII 开发自己的字符编码，例如 ISO/IEC 8859（欧洲字符集）、shift_Jis（日语字符集）、GBK（中文字符集）等 </p><p> ASCII 编码一览表  （加粗为控制字符，白色背景为可显示字符） </p><div class="table-container"><table><thead><tr><th>二进制</th><th>十进制</th><th>十六进制</th><th>字符/缩写</th><th>解释</th></tr></thead><tbody><tr><td><strong>00000000</strong></td><td><strong>0</strong></td><td><strong>00</strong></td><td><strong>NUL (NULL)</strong></td><td><strong>空字符</strong></td></tr><tr><td><strong>00000001</strong></td><td><strong>1</strong></td><td><strong>01</strong></td><td><strong>SOH (Start Of Headling)</strong></td><td><strong>标题开始</strong></td></tr><tr><td><strong>00000010</strong></td><td><strong>2</strong></td><td><strong>02</strong></td><td><strong>STX (Start Of Text)</strong></td><td><strong>正文开始</strong></td></tr><tr><td><strong>00000011</strong></td><td><strong>3</strong></td><td><strong>03</strong></td><td><strong>ETX (End Of Text)</strong></td><td><strong>正文结束</strong></td></tr><tr><td><strong>00000100</strong></td><td><strong>4</strong></td><td><strong>04</strong></td><td><strong>EOT (End Of Transmission)</strong></td><td><strong>传输结束</strong></td></tr><tr><td><strong>00000101</strong></td><td><strong>5</strong></td><td><strong>05</strong></td><td><strong>ENQ (Enquiry)</strong></td><td><strong>请求</strong></td></tr><tr><td><strong>00000110</strong></td><td><strong>6</strong></td><td><strong>06</strong></td><td><strong>ACK (Acknowledge)</strong></td><td><strong>回应/响应/收到通知</strong></td></tr><tr><td><strong>00000111</strong></td><td><strong>7</strong></td><td><strong>07</strong></td><td><strong>BEL (Bell)</strong></td><td><strong>响铃</strong></td></tr><tr><td><strong>00001000</strong></td><td><strong>8</strong></td><td><strong>08</strong></td><td><strong>BS (Backspace)</strong></td><td><strong>退格</strong></td></tr><tr><td><strong>00001001</strong></td><td><strong>9</strong></td><td><strong>09</strong></td><td><strong>HT (Horizontal Tab)</strong></td><td><strong>水平制表符</strong></td></tr><tr><td><strong>00001010</strong></td><td><strong>10</strong></td><td><strong>0A</strong></td><td><strong>LF/NL(Line Feed/New Line)</strong></td><td><strong>换行键</strong></td></tr><tr><td><strong>00001011</strong></td><td><strong>11</strong></td><td><strong>0B</strong></td><td><strong>VT (Vertical Tab)</strong></td><td><strong>垂直制表符</strong></td></tr><tr><td><strong>00001100</strong></td><td><strong>12</strong></td><td><strong>0C</strong></td><td><strong>FF/NP (Form Feed/New Page)</strong></td><td><strong>换页键</strong></td></tr><tr><td><strong>00001101</strong></td><td><strong>13</strong></td><td><strong>0D</strong></td><td><strong>CR (Carriage Return)</strong></td><td><strong>回车键</strong></td></tr><tr><td><strong>00001110</strong></td><td><strong>14</strong></td><td><strong>0E</strong></td><td><strong>SO (Shift Out)</strong></td><td><strong>不用切换</strong></td></tr><tr><td><strong>00001111</strong></td><td><strong>15</strong></td><td><strong>0F</strong></td><td><strong>SI (Shift In)</strong></td><td><strong>启用切换</strong></td></tr><tr><td><strong>00010000</strong></td><td><strong>16</strong></td><td><strong>10</strong></td><td><strong>DLE (Data Link Escape)</strong></td><td><strong>数据链路转义</strong></td></tr><tr><td><strong>00010001</strong></td><td><strong>17</strong></td><td><strong>11</strong></td><td><strong>DC1/XON (Device Control 1/Transmission On)</strong></td><td><strong>设备控制1/传输开始</strong></td></tr><tr><td><strong>00010010</strong></td><td><strong>18</strong></td><td><strong>12</strong></td><td><strong>DC2 (Device Control 2)</strong></td><td><strong>设备控制2</strong></td></tr><tr><td><strong>00010011</strong></td><td><strong>19</strong></td><td><strong>13</strong></td><td><strong>DC3/XOFF (Device Control 3/Transmission Off)</strong></td><td><strong>设备控制3/传输中断</strong></td></tr><tr><td><strong>00010100</strong></td><td><strong>20</strong></td><td><strong>14</strong></td><td><strong>DC4 (Device Control 4)</strong></td><td><strong>设备控制4</strong></td></tr><tr><td><strong>00010101</strong></td><td><strong>21</strong></td><td><strong>15</strong></td><td><strong>NAK (Negative Acknowledge)</strong></td><td><strong>无响应/非正常响应/拒绝接收</strong></td></tr><tr><td><strong>00010110</strong></td><td><strong>22</strong></td><td><strong>16</strong></td><td><strong>SYN (Synchronous Idle)</strong></td><td><strong>同步空闲</strong></td></tr><tr><td><strong>00010111</strong></td><td><strong>23</strong></td><td><strong>17</strong></td><td><strong>ETB (End of Transmission Block)</strong></td><td><strong>传输块结束/块传输终止</strong></td></tr><tr><td><strong>00011000</strong></td><td><strong>24</strong></td><td><strong>18</strong></td><td><strong>CAN (Cancel)</strong></td><td><strong>取消</strong></td></tr><tr><td><strong>00011001</strong></td><td><strong>25</strong></td><td><strong>19</strong></td><td><strong>EM (End of Medium)</strong></td><td><strong>已到介质末端/介质存储已满/介质中断</strong></td></tr><tr><td><strong>00011010</strong></td><td><strong>26</strong></td><td><strong>1A</strong></td><td><strong>SUB (Substitute)</strong></td><td><strong>替补/替换</strong></td></tr><tr><td><strong>00011011</strong></td><td><strong>27</strong></td><td><strong>1B</strong></td><td><strong>ESC (Escape)</strong></td><td><strong>逃离/取消</strong></td></tr><tr><td><strong>00011100</strong></td><td><strong>28</strong></td><td><strong>1C</strong></td><td><strong>FS (File Separator)</strong></td><td><strong>文件分割符</strong></td></tr><tr><td><strong>00011101</strong></td><td><strong>29</strong></td><td><strong>1D</strong></td><td><strong>GS (Group Separator)</strong></td><td><strong>组分隔符/分组符</strong></td></tr><tr><td><strong>00011110</strong></td><td><strong>30</strong></td><td><strong>1E</strong></td><td><strong>RS (Record Separator)</strong></td><td><strong>记录分离符</strong></td></tr><tr><td><strong>00011111</strong></td><td><strong>31</strong></td><td><strong>1F</strong></td><td><strong>US (Unit Separator)</strong></td><td><strong>单元分隔符</strong></td></tr><tr><td>00100000</td><td>32</td><td>20</td><td>(Space)</td><td>空格</td></tr><tr><td>00100001</td><td>33</td><td>21</td><td>!</td><td></td></tr><tr><td>00100010</td><td>34</td><td>22</td><td>“</td><td></td></tr><tr><td>00100011</td><td>35</td><td>23</td><td>#</td><td></td></tr><tr><td>00100100</td><td>36</td><td>24</td><td>$</td><td></td></tr><tr><td>00100101</td><td>37</td><td>25</td><td>%</td><td></td></tr><tr><td>00100110</td><td>38</td><td>26</td><td>&amp;</td><td></td></tr><tr><td>00100111</td><td>39</td><td>27</td><td>‘</td><td></td></tr><tr><td>00101000</td><td>40</td><td>28</td><td>(</td><td></td></tr><tr><td>00101001</td><td>41</td><td>29</td><td>)</td><td></td></tr><tr><td>00101010</td><td>42</td><td>2A</td><td>*</td><td></td></tr><tr><td>00101011</td><td>43</td><td>2B</td><td>+</td><td></td></tr><tr><td>00101100</td><td>44</td><td>2C</td><td>,</td><td></td></tr><tr><td>00101101</td><td>45</td><td>2D</td><td>-</td><td></td></tr><tr><td>00101110</td><td>46</td><td>2E</td><td>.</td><td></td></tr><tr><td>00101111</td><td>47</td><td>2F</td><td>/</td><td></td></tr><tr><td>00110000</td><td>48</td><td>30</td><td>0</td><td></td></tr><tr><td>00110001</td><td>49</td><td>31</td><td>1</td><td></td></tr><tr><td>00110010</td><td>50</td><td>32</td><td>2</td><td></td></tr><tr><td>00110011</td><td>51</td><td>33</td><td>3</td><td></td></tr><tr><td>00110100</td><td>52</td><td>34</td><td>4</td><td></td></tr><tr><td>00110101</td><td>53</td><td>35</td><td>5</td><td></td></tr><tr><td>00110110</td><td>54</td><td>36</td><td>6</td><td></td></tr><tr><td>00110111</td><td>55</td><td>37</td><td>7</td><td></td></tr><tr><td>00111000</td><td>56</td><td>38</td><td>8</td><td></td></tr><tr><td>00111001</td><td>57</td><td>39</td><td>9</td><td></td></tr><tr><td>00111010</td><td>58</td><td>3A</td><td>:</td><td></td></tr><tr><td>00111011</td><td>59</td><td>3B</td><td>;</td><td></td></tr><tr><td>00111100</td><td>60</td><td>3C</td><td>&lt;</td><td></td></tr><tr><td>00111101</td><td>61</td><td>3D</td><td>=</td><td></td></tr><tr><td>00111110</td><td>62</td><td>3E</td><td>&gt;</td><td></td></tr><tr><td>00111111</td><td>63</td><td>3F</td><td>?</td><td></td></tr><tr><td>01000000</td><td>64</td><td>40</td><td>@</td><td></td></tr><tr><td>01000001</td><td>65</td><td>41</td><td>A</td><td></td></tr><tr><td>01000010</td><td>66</td><td>42</td><td>B</td><td></td></tr><tr><td>01000011</td><td>67</td><td>43</td><td>C</td><td></td></tr><tr><td>01000100</td><td>68</td><td>44</td><td>D</td><td></td></tr><tr><td>01000101</td><td>69</td><td>45</td><td>E</td><td></td></tr><tr><td>01000110</td><td>70</td><td>46</td><td>F</td><td></td></tr><tr><td>01000111</td><td>71</td><td>47</td><td>G</td><td></td></tr><tr><td>01001000</td><td>72</td><td>48</td><td>H</td><td></td></tr><tr><td>01001001</td><td>73</td><td>49</td><td>I</td><td></td></tr><tr><td>01001010</td><td>74</td><td>4A</td><td>J</td><td></td></tr><tr><td>01001011</td><td>75</td><td>4B</td><td>K</td><td></td></tr><tr><td>01001100</td><td>76</td><td>4C</td><td>L</td><td></td></tr><tr><td>01001101</td><td>77</td><td>4D</td><td>M</td><td></td></tr><tr><td>01001110</td><td>78</td><td>4E</td><td>N</td><td></td></tr><tr><td>01001111</td><td>79</td><td>4F</td><td>O</td><td></td></tr><tr><td>01010000</td><td>80</td><td>50</td><td>P</td><td></td></tr><tr><td>01010001</td><td>81</td><td>51</td><td>Q</td><td></td></tr><tr><td>01010010</td><td>82</td><td>52</td><td>R</td><td></td></tr><tr><td>01010011</td><td>83</td><td>53</td><td>S</td><td></td></tr><tr><td>01010100</td><td>84</td><td>54</td><td>T</td><td></td></tr><tr><td>01010101</td><td>85</td><td>55</td><td>U</td><td></td></tr><tr><td>01010110</td><td>86</td><td>56</td><td>V</td><td></td></tr><tr><td>01010111</td><td>87</td><td>57</td><td>W</td><td></td></tr><tr><td>01011000</td><td>88</td><td>58</td><td>X</td><td></td></tr><tr><td>01011001</td><td>89</td><td>59</td><td>Y</td><td></td></tr><tr><td>01011010</td><td>90</td><td>5A</td><td>Z</td><td></td></tr><tr><td>01011011</td><td>91</td><td>5B</td><td>[</td><td></td></tr><tr><td>01011100</td><td>92</td><td>5C</td><td>\</td><td></td></tr><tr><td>01011101</td><td>93</td><td>5D</td><td>]</td><td></td></tr><tr><td>01011110</td><td>94</td><td>5E</td><td>^</td><td></td></tr><tr><td>01011111</td><td>95</td><td>5F</td><td>_</td><td></td></tr><tr><td>01100000</td><td>96</td><td>60</td><td>`</td><td></td></tr><tr><td>01100001</td><td>97</td><td>61</td><td>a</td><td></td></tr><tr><td>01100010</td><td>98</td><td>62</td><td>b</td><td></td></tr><tr><td>01100011</td><td>99</td><td>63</td><td>c</td><td></td></tr><tr><td>01100100</td><td>100</td><td>64</td><td>d</td><td></td></tr><tr><td>01100101</td><td>101</td><td>65</td><td>e</td><td></td></tr><tr><td>01100110</td><td>102</td><td>66</td><td>f</td><td></td></tr><tr><td>01100111</td><td>103</td><td>67</td><td>g</td><td></td></tr><tr><td>01101000</td><td>104</td><td>68</td><td>h</td><td></td></tr><tr><td>01101001</td><td>105</td><td>69</td><td>i</td><td></td></tr><tr><td>01101010</td><td>106</td><td>6A</td><td>j</td><td></td></tr><tr><td>01101011</td><td>107</td><td>6B</td><td>k</td><td></td></tr><tr><td>01101100</td><td>108</td><td>6C</td><td>l</td><td></td></tr><tr><td>01101101</td><td>109</td><td>6D</td><td>m</td><td></td></tr><tr><td>01101110</td><td>110</td><td>6E</td><td>n</td><td></td></tr><tr><td>01101111</td><td>111</td><td>6F</td><td>o</td><td></td></tr><tr><td>01110000</td><td>112</td><td>70</td><td>p</td><td></td></tr><tr><td>01110001</td><td>113</td><td>71</td><td>q</td><td></td></tr><tr><td>01110010</td><td>114</td><td>72</td><td>r</td><td></td></tr><tr><td>01110011</td><td>115</td><td>73</td><td>s</td><td></td></tr><tr><td>01110100</td><td>116</td><td>74</td><td>t</td><td></td></tr><tr><td>01110101</td><td>117</td><td>75</td><td>u</td><td></td></tr><tr><td>01110110</td><td>118</td><td>76</td><td>v</td><td></td></tr><tr><td>01110111</td><td>119</td><td>77</td><td>w</td><td></td></tr><tr><td>01111000</td><td>120</td><td>78</td><td>x</td><td></td></tr><tr><td>01111001</td><td>121</td><td>79</td><td>y</td><td></td></tr><tr><td>01111010</td><td>122</td><td>7A</td><td>z</td><td></td></tr><tr><td>01111011</td><td>123</td><td>7B</td><td>{</td><td></td></tr><tr><td>01111100</td><td>124</td><td>7C</td><td>\</td><td></td><td></td></tr><tr><td>01111101</td><td>125</td><td>7D</td><td>}</td><td></td></tr><tr><td>01111110</td><td>126</td><td>7E</td><td>~</td><td></td></tr><tr><td>01111111</td><td>127</td><td>7F</td><td>DEL (Delete)</td><td>删除</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> ASCII </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法(三)</title>
      <link href="/2022/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%B8%89/"/>
      <url>/2022/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法-三"><a href="#数据结构与算法-三" class="headerlink" title="数据结构与算法(三)"></a>数据结构与算法(三)</h1><h2 id="查找算法："><a href="#查找算法：" class="headerlink" title="查找算法："></a>查找算法：</h2><p>在java中，我们常用的查找有四种:<br>    1) 顺序(线性)查找<br>    2) 二分查找/折半查找<br>   3) 插值查找<br>   4) 斐波那契查找</p><p>线性查找：</p><p><strong>该查找单纯使用for循环，比较简单，在此不再做多描述。</strong></p><h3 id="二分查找："><a href="#二分查找：" class="headerlink" title="二分查找："></a>二分查找：</h3><p>二分查找的思路分析</p><ol><li><p>首先确定该数组的中间的下标<br>mid = (left + right) / 2</p><ol><li><p>然后让需要查找的数 findVal 和 arr[mid] 比较</p><ol><li>1 findVal &gt; arr[mid] ,  说明你要查找的数在mid 的右边, 因此需要递归的向右查找<br>2.2 findVal &lt; arr[mid], 说明你要查找的数在mid 的左边, 因此需要递归的向左查找<br>2.3  findVal == arr[mid] 说明找到，就返回</li></ol><p>//什么时候我们需要结束递归.<br>1) 找到就结束递归<br>2) 递归完整个数组，仍然没有找到findVal ，也需要结束递归  当 left &gt; right 就需要退出</p></li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找前提是该数组是有序的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">search</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[]arr=&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">89</span>,<span class="number">1000</span>,<span class="number">1000</span>,<span class="number">1000</span>,<span class="number">1234</span>&#125;;</span><br><span class="line">        <span class="type">int</span> resultIndex=binarySearch(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,<span class="number">1234</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;索引&quot;</span>+resultIndex);</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">res</span> <span class="operator">=</span> binarySearch2(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分查找方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[]arr,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> findVal)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> midVal=arr[mid];</span><br><span class="line">        <span class="keyword">if</span> (findVal&gt;midVal)&#123;<span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, mid+<span class="number">1</span>, right, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal&lt;midVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, left, mid-<span class="number">1</span>, findVal);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title function_">binarySearch2</span><span class="params">(<span class="type">int</span>[]arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> findVal)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> midVal=arr[mid];</span><br><span class="line">        <span class="keyword">if</span> (findVal&gt;midVal)&#123;<span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch2(arr, mid+<span class="number">1</span>, right, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal&lt;midVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch2(arr, left, mid-<span class="number">1</span>, findVal);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; resIndexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> temp=mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (temp&lt;<span class="number">0</span> || arr[temp]!=findVal)&#123;<span class="comment">//退出操作</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则</span></span><br><span class="line">                resIndexList.add(temp);</span><br><span class="line">                temp--;</span><br><span class="line">            &#125;</span><br><span class="line">            resIndexList.add(mid);</span><br><span class="line">            temp=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (temp&gt;arr.length-<span class="number">1</span> || arr[temp]!=findVal)&#123;<span class="comment">//退出操作</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则</span></span><br><span class="line">                resIndexList.add(temp);</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> resIndexList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="插值查找："><a href="#插值查找：" class="headerlink" title="插值查找："></a>插值查找：</h3><p>插值查找算法的 举例说明 </p><p>数组  arr = [1, 2, 3, ……., 100]</p><p>假如我们需要查找的值  1 </p><p>使用二分查找的话，我们需要多次递归，才能找到 1</p><p>使用插值查找算法<br>int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])</p><p>int mid = 0 + (99 - 0) <em> (1 - 1)/ (100 - 1) = 0 + 99 </em> 0 / 99 = 0 </p><p>比如我们查找的值 100</p><p>int mid = 0 + (99 - 0) <em> (100 - 1) / (100 - 1) = 0 + 99 </em> 99 / 99 = 0 + 99 = 99 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertValueSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[]arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            arr[i]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> InsertValueSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">55</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插值算法也要求数组是有序的</span></span><br><span class="line">    <span class="comment">//如果找到，返回对应下标</span></span><br><span class="line">    <span class="comment">//没有找到，返回-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">InsertValueSearch</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> findValue)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left&gt;right||findValue&lt;arr[<span class="number">0</span>]||findValue&gt;arr[arr.length-<span class="number">1</span>])&#123;<span class="comment">//后两个判断必须加，并不是可有可无的,没有可能会造成mid越界</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=left + (right-left) * (findValue-arr[left]) / (arr[right]-arr[left]);</span><br><span class="line">        <span class="type">int</span> midVal=arr[mid];</span><br><span class="line">        <span class="keyword">if</span> (findValue&gt;midVal)&#123;<span class="comment">//向右边递归</span></span><br><span class="line">            <span class="keyword">return</span> InsertValueSearch(arr, mid+<span class="number">1</span>, right, findValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findValue&lt;midVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> InsertValueSearch(arr, left, mid-<span class="number">1</span>, findValue);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="哈希表："><a href="#哈希表：" class="headerlink" title="哈希表："></a>哈希表：</h2><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> HashTab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTabDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建哈希表</span></span><br><span class="line">        <span class="type">HashTab</span> <span class="variable">hashTab</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashTab</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写一个菜单</span></span><br><span class="line">        String key=<span class="string">&quot; &quot;</span>;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;add: 添加雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;list: 显示雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit: 退出系统&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;find: 查找雇员&quot;</span>);</span><br><span class="line">            key= sc.next();</span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入id&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入名字&quot;</span>);</span><br><span class="line">                    String name= sc.next();</span><br><span class="line">                    <span class="comment">//创建雇员</span></span><br><span class="line">                    <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(id, name);</span><br><span class="line">                    hashTab.add(emp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;list&quot;</span>:</span><br><span class="line">                    hashTab.List();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;find&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入要查找到id&quot;</span>);</span><br><span class="line">                    id=sc.nextInt();</span><br><span class="line">                    hashTab.findEmpById(id);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    sc.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正真开始写哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTab</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EmpLinkedList[] empLinkedLists;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;<span class="comment">//表示多少条链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashTab</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size=size;</span><br><span class="line">        empLinkedLists=<span class="keyword">new</span> <span class="title class_">EmpLinkedList</span>[size];</span><br><span class="line">        <span class="comment">//如果不初始化每一个链表，会在add被调用时候，造成空指针异常的现象出现</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            empLinkedLists[i]=<span class="keyword">new</span> <span class="title class_">EmpLinkedList</span>();<span class="comment">//每一个指针都会造成异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Emp emp)</span>&#123;</span><br><span class="line">        <span class="comment">//根据员工id，得到该员工应该添加到哪条链表</span></span><br><span class="line">        <span class="type">int</span> empLinkedListNO=HashFun(emp.id);</span><br><span class="line">        <span class="comment">//将emp添加到对应的链表中</span></span><br><span class="line"></span><br><span class="line">        empLinkedLists[empLinkedListNO].add(emp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历所有链表</span></span><br><span class="line">    <span class="comment">//遍历哈希表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">List</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            empLinkedLists[i].List(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编写一个散列函数,使用取模</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">HashFun</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id%size;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据输入的id查找雇员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findEmpById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="comment">//使用散列函数确定到哪条链表查找</span></span><br><span class="line">        <span class="type">int</span> empLinkedListNO=HashFun(id);</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> empLinkedLists[empLinkedListNO].findEmpById(id);</span><br><span class="line">        <span class="keyword">if</span> (emp!=<span class="literal">null</span>)&#123;<span class="comment">//找到</span></span><br><span class="line">            System.out.println(<span class="string">&quot;在第&quot;</span>+empLinkedListNO+<span class="string">&quot;条链表中找到雇员&quot;</span>+id);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在哈希表中没有找到该雇员&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表示一个雇员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Emp</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Emp next;<span class="comment">//next默认为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Emp</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建employlinkedlist</span></span><br><span class="line"><span class="comment">//假定，当添加雇员时，id是自增长的，所以分配是从小到大的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmpLinkedList</span>&#123;</span><br><span class="line">    <span class="comment">//头指针直接指向第一个部员</span></span><br><span class="line">    <span class="keyword">private</span> Emp head;<span class="comment">//默认空,null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Emp emp)</span>&#123;</span><br><span class="line">        <span class="comment">//如果添加第一个雇员</span></span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>)&#123;</span><br><span class="line">            head=emp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不是第一个雇员，使用辅助指针，定位到最后</span></span><br><span class="line">        Emp curEmp=head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next==<span class="literal">null</span>)&#123;<span class="comment">//说明到链表最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp=curEmp.next;<span class="comment">//往后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出时直接将emp加入链表</span></span><br><span class="line">        curEmp.next=emp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">List</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+no+<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;当前信息为：&quot;</span>);</span><br><span class="line">        Emp curEmp=head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;=&gt; id=%d name=%s\t&quot;</span>,curEmp.id,curEmp.name);</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp=curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据id查找雇员</span></span><br><span class="line">    <span class="comment">//找到，返回Emp，没有找到，就返回null</span></span><br><span class="line">    <span class="keyword">public</span> Emp <span class="title function_">findEmpById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助指针</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.id==id)&#123;<span class="comment">//找到</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//这是curEmp就指向要查找的雇员</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curEmp.next==<span class="literal">null</span>)&#123;<span class="comment">//说明遍历当前链表没有找到该雇员</span></span><br><span class="line">                curEmp = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;<span class="comment">//以后</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curEmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="树结构基础"><a href="#树结构基础" class="headerlink" title="树结构基础:"></a>树结构基础:</h2><p>树的常用术语(结合示意图理解):<br>节点<br>根节点<br>父节点<br>子节点<br>叶子节点 (没有子节点的节点)<br>节点的权(节点值)<br>路径(从root节点找到该节点的路线)<br>层<br>子树<br>树的高度(最大层数)<br>森林 :多颗子树构成森林</p><p><img src="C:\Users\juan\AppData\Roaming\Typora\typora-user-images\1671766895119.png" alt="1671766895119"></p><h3 id="二叉树："><a href="#二叉树：" class="headerlink" title="二叉树："></a>二叉树：</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><ol><li>树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。</li><li>二叉树的子节点分为<strong>左节点</strong>和<strong>右节点</strong>。</li><li>如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为<strong>满二叉树</strong>。</li><li>如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为<strong>完全二叉树</strong>。</li></ol><h4 id="二叉树的三种遍历："><a href="#二叉树的三种遍历：" class="headerlink" title="二叉树的三种遍历："></a>二叉树的三种遍历：</h4><p>前序遍历: 先输出父节点，再遍历左子树和右子树<br>中序遍历: 先遍历左子树，再输出父节点，再遍历右子树<br>后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的前中后遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeparateTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//先建立节点，再建立树</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>,<span class="string">&quot;吴用&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>,<span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>,<span class="string">&quot;林冲&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>,<span class="string">&quot;关胜&quot;</span>);</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line"></span><br><span class="line">        node1.setLeftNode(node2);</span><br><span class="line">        node1.setRightNode(node3);</span><br><span class="line">        node3.setRightNode(node4);</span><br><span class="line">        node3.setLeftNode(node5);</span><br><span class="line">        binaryTree.setRoot(node1);</span><br><span class="line">        <span class="comment">//前序</span></span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        <span class="comment">//中序</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">        binaryTree.infixOrder();</span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历&quot;</span>);</span><br><span class="line">        binaryTree.postOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;<span class="comment">//根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infix();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先建立节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode leftNode;<span class="comment">//默认为空</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode rightNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getLeftNode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftNode</span><span class="params">(HeroNode leftNode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftNode = leftNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getRightNode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightNode</span><span class="params">(HeroNode rightNode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightNode = rightNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name  +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编写前序遍历的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//先输出当前父节点</span></span><br><span class="line">        <span class="comment">//递归向左子树递归</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.leftNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.leftNode.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.rightNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.rightNode.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infix</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.leftNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.leftNode.infix();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出父节点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//递归向右子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.rightNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.rightNode.infix();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树递归</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.leftNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.leftNode.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.rightNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.rightNode.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="二叉树的三种查找："><a href="#二叉树的三种查找：" class="headerlink" title="二叉树的三种查找："></a>二叉树的三种查找：</h4><p><strong>思路</strong>：</p><ol><li>先判断当前节点no是否等于要查找的。</li><li>如果是相等，则返回当前节点。</li><li>如果不等，则判断当前节点的左子节点是否为空，不为空，则递归前序查找。</li><li>如果向左递归没查到，则判断右子节点是否为空，如果不为空，则向右递归。</li><li>如果在途中找到了，则返回。</li><li>中序，后序都按照此思路就进行。</li></ol><p><strong>Node节点类中的方法定义：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  HeroNode <span class="title function_">PreOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="comment">//比较当前节点是不是</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no==no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode resNode=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.leftNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            resNode=<span class="built_in">this</span>.leftNode.PreOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode!=<span class="literal">null</span>)&#123;<span class="comment">//说明左子树找到了</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.rightNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            resNode=<span class="built_in">this</span>.rightNode.PreOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        HeroNode resNode=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.leftNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            resNode=<span class="built_in">this</span>.leftNode.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode!=<span class="literal">null</span>)&#123;<span class="comment">//说明左子树找到了</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no==no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.rightNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            resNode=<span class="built_in">this</span>.rightNode.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">PostSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        HeroNode resNode=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.leftNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            resNode=<span class="built_in">this</span>.leftNode.PostSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode!=<span class="literal">null</span>)&#123;<span class="comment">//说明左子树找到了</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no==no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.rightNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            resNode=<span class="built_in">this</span>.rightNode.PostSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Tree类中的定义：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> HeroNode <span class="title function_">PreOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.PreOrderSearch(no);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">InfixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">PostSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.PostSearch(no);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>main方法中的使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历方式&quot;</span>);</span><br><span class="line">        HeroNode resNode=binaryTree.PreOrderSearch(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span> (resNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到了，信息为:&quot;</span>+resNode.toString());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树删除节点方法："><a href="#二叉树删除节点方法：" class="headerlink" title="二叉树删除节点方法："></a>二叉树删除节点方法：</h4><p>此处，作者不了解二叉树如何删除树节点，此处仅为删除叶子节点。<del>嘤嘤嘤</del></p><ol><li>此处，判断要删除的节点应该根据当前节点的子节点来判断，这种方法更适合判断</li><li>如果当前节点的左子节点不为空，并且左子节点就是要删除的节点，就赋空返回。</li><li>如果当前节点的右子节点不为空，并且右子节点就是要删除的节点，同样操作。</li><li>如果前两步没有删除掉节点，那么就需要我们相应的进行递归删除操作。(递归也是从左往右的)</li></ol><p><strong>Node节点代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DeleteNode</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.leftNode!=<span class="literal">null</span>&amp;&amp;<span class="built_in">this</span>.leftNode.no==no)&#123;</span><br><span class="line">            <span class="built_in">this</span>.leftNode=<span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.rightNode!=<span class="literal">null</span>&amp;&amp;<span class="built_in">this</span>.rightNode.no==no)&#123;</span><br><span class="line">            <span class="built_in">this</span>.rightNode=<span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.leftNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.leftNode.DeleteNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.rightNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.rightNode.DeleteNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Tree节点代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DeleteNode</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (root.getNo()==no)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;要删除的就是root&quot;</span>);</span><br><span class="line">                root=<span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                root.DeleteNode(no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空树，不能删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="顺序存储二叉树："><a href="#顺序存储二叉树：" class="headerlink" title="顺序存储二叉树："></a>顺序存储二叉树：</h3><p>顺序存储二叉树的概念</p><p>顺序存储二叉树的特点:</p><ol><li>顺序二叉树通常只考虑完全二叉树</li><li>第n个元素的左子节点为  2 * n + 1 </li><li>第n个元素的右子节点为  2 * n + 2</li><li>第n个元素的父节点为  (n-1) / 2</li><li>n : 表示二叉树中的第几个元素(默认从0开始编号)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="comment">//创建一个对象那个</span></span><br><span class="line">        <span class="type">ArrBinaryTree</span> <span class="variable">arrBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrBinaryTree</span>(arr);</span><br><span class="line">        arrBinaryTree.preOrder(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写一个ArrayBinaryTree，实现顺序存储二叉树遍历</span></span><br><span class="line"><span class="comment">//这个树必须是完全二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrBinaryTree</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;<span class="comment">//存储数据节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrBinaryTree</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编写一个方法，完成顺序存储二叉树的前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="comment">//如果数组为空，或者arr.length = 0</span></span><br><span class="line">        <span class="keyword">if</span> (arr==<span class="literal">null</span>||arr.length==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组为空，不能按照二叉树的前序遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出当前元素</span></span><br><span class="line">        System.out.println(arr[index]);</span><br><span class="line">        <span class="comment">//向左递归遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((index*<span class="number">2</span>+<span class="number">1</span>)&lt;arr.length)&#123;</span><br><span class="line">            preOrder(index*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右递归遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((index*<span class="number">2</span>+<span class="number">2</span>)&lt;arr.length)&#123;</span><br><span class="line">            preOrder(index*<span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索化二叉树："><a href="#线索化二叉树：" class="headerlink" title="线索化二叉树："></a>线索化二叉树：</h3><p><strong>问题提出：</strong>如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点</p><p><strong>线索二叉树基本介绍</strong></p><ol><li>n个结点的二叉链表中含有n+1  【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”）</li><li>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种</li><li>一个结点的前一个结点，称为前驱结点</li><li>一个结点的后一个结点，称为后继结点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Tree.ThreadBinary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">6</span>, <span class="string">&quot;smith&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">8</span>, <span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">10</span>, <span class="string">&quot;king&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">14</span>, <span class="string">&quot;dim&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二叉树，后面递归创建，现在手动处理</span></span><br><span class="line">        root.setLeftNode(node2);</span><br><span class="line">        root.setRightNode(node3);</span><br><span class="line">        node2.setLeftNode(node4);</span><br><span class="line">        node2.setRightNode(node5);</span><br><span class="line">        node3.setLeftNode(node6);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line">        binaryTree.ThreadNodes();</span><br><span class="line">        <span class="comment">//测试:以10测试</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> node5.getLeftNode();</span><br><span class="line">        System.out.println(leftNode);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> node5.getRightNode();</span><br><span class="line">        System.out.println(rightNode);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现线索化功能的二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;<span class="comment">//根节点</span></span><br><span class="line">    <span class="comment">//为了实现线索化，需要创建一个指向当前节点的前驱节点的一个指针</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode pre;<span class="comment">//默认为null;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ThreadNodes</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.ThreadNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写对二叉树进行中序线索化的方法</span></span><br><span class="line">    <span class="comment">//node就是当前需要线索化的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ThreadNodes</span><span class="params">(HeroNode node)</span>&#123;</span><br><span class="line">        <span class="comment">//如果node==null，不能线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.先线索化左子树</span></span><br><span class="line">        ThreadNodes(node.getLeftNode());</span><br><span class="line">        <span class="comment">//2.线索化当前节点</span></span><br><span class="line">        <span class="comment">//先处理当前节点的前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeftNode()==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//让当前节点的左指针指向前驱节点</span></span><br><span class="line">            node.setLeftNode(pre);</span><br><span class="line">            <span class="comment">//修改当前节点左指针的类型</span></span><br><span class="line">            node.setLeftType(<span class="number">1</span>);<span class="comment">//左指针指向前驱节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (pre!=<span class="literal">null</span>&amp;&amp;pre.getRightNode()==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//让前驱节点的右指针指向当前节点</span></span><br><span class="line">            pre.setRightNode(node);</span><br><span class="line">            <span class="comment">//修改前驱节点的右指针类型</span></span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre=node;<span class="comment">//最重要的一句，每处理一个节点后，让当前节点是下一个节点的前驱节点</span></span><br><span class="line">        <span class="comment">//3.线索化右子树</span></span><br><span class="line">        ThreadNodes(node.getRightNode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infix();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">PreOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.PreOrderSearch(no);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">InfixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">PostSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.PostSearch(no);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DeleteNode</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (root.getNo()==no)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;要删除的就是root&quot;</span>);</span><br><span class="line">                root=<span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                root.DeleteNode(no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空树，不能删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode leftNode;<span class="comment">//默认为空</span></span><br><span class="line">    <span class="keyword">private</span>  HeroNode rightNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果leftType==0，表示指向左子树，1表示指向后继节点。</span></span><br><span class="line">    <span class="comment">//如果rightType==0，表示指向右子树，1表示指向后继节点。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftType</span><span class="params">(<span class="type">int</span> leftType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightType</span><span class="params">(<span class="type">int</span> rightType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getLeftNode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftNode</span><span class="params">(HeroNode leftNode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftNode = leftNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getRightNode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightNode</span><span class="params">(HeroNode rightNode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightNode = rightNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name  +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编写前序遍历的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//先输出当前父节点</span></span><br><span class="line">        <span class="comment">//递归向左子树递归</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.leftNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.leftNode.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.rightNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.rightNode.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infix</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.leftNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.leftNode.infix();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出父节点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//递归向右子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.rightNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.rightNode.infix();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树递归</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.leftNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.leftNode.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.rightNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.rightNode.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">PreOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="comment">//比较当前节点是不是</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no==no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode resNode=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.leftNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            resNode=<span class="built_in">this</span>.leftNode.PreOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode!=<span class="literal">null</span>)&#123;<span class="comment">//说明左子树找到了</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.rightNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            resNode=<span class="built_in">this</span>.rightNode.PreOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        HeroNode resNode=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.leftNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            resNode=<span class="built_in">this</span>.leftNode.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode!=<span class="literal">null</span>)&#123;<span class="comment">//说明左子树找到了</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no==no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.rightNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            resNode=<span class="built_in">this</span>.rightNode.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">PostSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        HeroNode resNode=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.leftNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            resNode=<span class="built_in">this</span>.leftNode.PostSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode!=<span class="literal">null</span>)&#123;<span class="comment">//说明左子树找到了</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no==no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.rightNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            resNode=<span class="built_in">this</span>.rightNode.PostSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归删除节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DeleteNode</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.leftNode!=<span class="literal">null</span>&amp;&amp;<span class="built_in">this</span>.leftNode.no==no)&#123;</span><br><span class="line">            <span class="built_in">this</span>.leftNode=<span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.rightNode!=<span class="literal">null</span>&amp;&amp;<span class="built_in">this</span>.rightNode.no==no)&#123;</span><br><span class="line">            <span class="built_in">this</span>.rightNode=<span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.leftNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.leftNode.DeleteNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.rightNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.rightNode.DeleteNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del><strong>遍历功能暂时未实现，等写者再研究研究。</strong></del></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法(二)</title>
      <link href="/2022/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C/"/>
      <url>/2022/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法-二"><a href="#数据结构与算法-二" class="headerlink" title="数据结构与算法(二)"></a>数据结构与算法(二)</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ol><li>栈的英文为(stack)</li><li>栈是一个先入后出(FILO-First In Last Out)的有序列表。</li><li>栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。</li><li>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</li></ol><p>实现 栈的 思路分析</p><ol><li>使用数组来模拟栈</li><li>定义一个 top  来表示栈顶，初始化 为  -1</li><li>入栈的操作，当有数据加入到栈时， <strong>top++;  stack[top] = data;</strong></li><li>出栈的操作， <strong>int value = stack[top]; top—, return value</strong></li></ol><p>构建栈的一些常用操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack;<span class="comment">//数组，数组模拟栈，数据就放在该数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">//top表示栈顶，初始化为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        stack=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="built_in">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> top==maxSize-<span class="number">1</span>;<span class="comment">//判断栈满</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Push</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top]=value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="comment">//抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈空,无数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">List</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//遍历时，需要从栈顶开始显示数据</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空，没有数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=top;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Stack:&quot;</span>+stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈实现普通计算器："><a href="#栈实现普通计算器：" class="headerlink" title="栈实现普通计算器："></a>栈实现普通计算器：</h3><p>使用栈完成表达式的计算 思路</p><ol><li><p>通过一个 index  值（索引），来遍历我们的表达式</p></li><li><p>如果我们发现是一个数字, 就直接入数栈</p></li><li><p>如果发现扫描到是一个符号,  就分如下情况</p><p>3.1 如果发现当前的符号栈为 空，就直接入栈<br>3.2 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符， 就需要从数栈中pop出两个数,在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈， 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.</p><p>当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.</p></li><li><p>最后在数栈只有一个数字，就是表达式的结果</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//完成表达式的运算</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;70+2*6-4&quot;</span>;</span><br><span class="line">        <span class="comment">//创建数栈和符号栈</span></span><br><span class="line">        <span class="type">ArrayStack2</span> <span class="variable">numberStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack2</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ArrayStack2</span> <span class="variable">operStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack2</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//定义需要的相关变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用于扫描的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oper</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;<span class="comment">//将每次扫描得到的char保存到ch中</span></span><br><span class="line">        String keepNum=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//开始循环扫描式子</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//依次得到expression的每一个字符</span></span><br><span class="line">            ch = expression.substring(index, index + <span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//判断ch，做相应处理</span></span><br><span class="line">            <span class="keyword">if</span> (operStack.isOper(ch)) &#123;<span class="comment">//如果是符号</span></span><br><span class="line">                <span class="comment">//看当前是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (!operStack.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">//如果当前的操作符的优先级小于或者等于栈中的操作符</span></span><br><span class="line">                    <span class="comment">//就需要从数栈中pop出两个数,在从符号栈中pop出一个符号，进行运算</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (operStack.priority(ch) &lt;= operStack.priority(operStack.Pick())) &#123;</span><br><span class="line">                        <span class="keyword">while</span> (operStack.priority(ch) &lt;= operStack.priority(operStack.Pick()))&#123;</span><br><span class="line">                            number1 = numberStack.Pop();</span><br><span class="line">                            number2 = numberStack.Pop();</span><br><span class="line">                            oper = operStack.Pop();</span><br><span class="line">                            res = numberStack.cal(number1, number2, oper);</span><br><span class="line">                            <span class="comment">//把运算结果入数栈</span></span><br><span class="line">                            numberStack.Push(res);</span><br><span class="line">                            <span class="keyword">if</span> (operStack.priority(ch) &gt; operStack.priority(operStack.Pick())||operStack.isEmpty()||numberStack.isEmpty())&#123;</span><br><span class="line">                                <span class="comment">//把符号入栈</span></span><br><span class="line">                                operStack.Push(ch);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//当前的操作符的优先级大于栈中的运算符</span></span><br><span class="line">                        operStack.Push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//为空，直接入栈</span></span><br><span class="line">                    operStack.Push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是数。则直接入数栈</span></span><br><span class="line">                <span class="comment">//numberStack.Push(ch - 48);//一定要减去48，因为Ascll表,但无法处理多位数</span></span><br><span class="line">                keepNum+=ch;</span><br><span class="line">                <span class="comment">//判断下一个字符是不是数字，如果是数字，就继续扫描</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果ch已经是exprssion的最后一位，就直接入栈</span></span><br><span class="line">                <span class="keyword">if</span> (index==expression.length()-<span class="number">1</span>)&#123;</span><br><span class="line">                    numberStack.Push(Integer.parseInt(keepNum));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (operStack.isOper(expression.substring(index+<span class="number">1</span>,index+<span class="number">2</span>).charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">                    <span class="comment">//如果后一位是运算符，入栈</span></span><br><span class="line">                    numberStack.Push(Integer.parseInt(keepNum));</span><br><span class="line">                    <span class="comment">//必须要把keepNum清空</span></span><br><span class="line">                    keepNum=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让index加一，并判断是否扫描到expression最后</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= expression.length()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//如果符号栈为空，则计算到最后的结果，数栈中只有一个数值</span></span><br><span class="line">            <span class="keyword">if</span> (operStack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            number1 = numberStack.Pop();</span><br><span class="line">            number2 = numberStack.Pop();</span><br><span class="line">            oper = operStack.Pop();</span><br><span class="line">            res = numberStack.cal(number1, number2, oper);</span><br><span class="line">            numberStack.Push(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出最后的数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;表达式是:&quot;</span> + numberStack.Pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先创建一个栈，直接使用前面创建好的栈</span></span><br><span class="line"><span class="comment">//定义表示栈结构,需要拓展功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack;<span class="comment">//数组，数组模拟栈，数据就放在该数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//top表示栈顶，初始化为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack2</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="built_in">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;<span class="comment">//判断栈满</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Push</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈空,无数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">List</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//遍历时，需要从栈顶开始显示数据</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空，没有数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Stack:&quot;</span> + stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回运算符的优先级,优先级是程序员定义的,优先级使用数字表示</span></span><br><span class="line">    <span class="comment">//数字越大，则优先级越高</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">int</span> oper)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (oper == <span class="string">&#x27;*&#x27;</span>||oper == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&#x27;+&#x27;</span>||oper==<span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//假定目前计算式只有加减乘除</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是不是一个运算符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOper</span><span class="params">(<span class="type">char</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val == <span class="string">&#x27;+&#x27;</span> ||val == <span class="string">&#x27;-&#x27;</span> ||val==<span class="string">&#x27;*&#x27;</span>||val==<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算方法,char和int可以混用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2,<span class="type">int</span> oper)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//res用于存放计算结果</span></span><br><span class="line">        <span class="keyword">switch</span> (oper)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                res=num1+num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                res=num2-num1;<span class="comment">//后弹出的数作为被减数</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                res=num1*num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                res=num2/num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看的栈的方法,可以返回当前栈顶的值，但不是真正的pop</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Pick</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>此处的计算器中有非常严重的错误，栈的容量内存方面仍未搞清楚，并不是一个正真的计算器,故需要再次修改</strong></p><h3 id="前缀-中缀-后缀表达式："><a href="#前缀-中缀-后缀表达式：" class="headerlink" title="前缀,中缀,后缀表达式："></a>前缀,中缀,后缀表达式：</h3><p>例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:</p><p>从左至右扫描，将3和4压入堆栈；<br>遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；<br>将5入栈；<br>接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；<br>将6入栈；<br>最后是-运算符，计算出35-6的值，即29，由此得出最终结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">polandNotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//先定义一个逆波兰表达式</span></span><br><span class="line">        <span class="comment">//说明：数字和符号使用空格隔开</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">suffixExpression</span> <span class="operator">=</span> <span class="string">&quot;30 4 + 5 * 6 -&quot;</span>;</span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1.先将suffixExpression放到ArrayList中</span></span><br><span class="line">        <span class="comment">//2.将ArrayList传递一个方法，配合栈完成计算</span></span><br><span class="line">        List&lt;String &gt; epnList = getListString(suffixExpression);</span><br><span class="line">        System.out.println(<span class="string">&quot;epnList&quot;</span>+epnList);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> calculate(epnList);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getListString</span><span class="params">(String  suffixExpression )</span>&#123;</span><br><span class="line">        <span class="comment">//进行分割</span></span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String &gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String ele:split)&#123;</span><br><span class="line">            list.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成后缀表达式的运算</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(List&lt;String &gt; ls)</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个栈,只需要一个栈即可</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item:ls)&#123;</span><br><span class="line">            <span class="comment">//这里使用正则表达式</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;<span class="comment">//匹配的是多位数</span></span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//pop出两个数并运算,再入栈</span></span><br><span class="line">                <span class="type">int</span> num2=Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> num1=Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (item.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                    res = num1+num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                    res  = num1-num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                   res= num1*num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                  res=  num1/num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把res入栈</span></span><br><span class="line">                stack.push(Integer.toString(res));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后的结果就是栈中的数据</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="中缀表达式转后缀表达式："><a href="#中缀表达式转后缀表达式：" class="headerlink" title="中缀表达式转后缀表达式："></a>中缀表达式转后缀表达式：</h4><p>具体步骤如下:</p><ol><li><p>初始化两个栈：运算符栈s1和储存中间结果的栈s2；</p></li><li><p>从左至右扫描中缀表达式；</p></li><li><p>遇到操作数时，将其压s2；</p></li><li><p>遇到运算符时，比较其与s1栈顶运算符的优先级：</p><p>   4.1  如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</p><ol><li><p>2  否则，若优先级比栈顶运算符的高，也将运算符压入s1；</p><p>4.3否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较；    </p></li></ol></li></ol><p>举例：1+((2+3)×4)-5转后缀</p><div class="table-container"><table><thead><tr><th>扫描到的元素</th><th>s2(栈底-&gt;栈顶)</th><th>s1 (栈底-&gt;栈顶)</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>空</td><td>数字，直接入栈</td></tr><tr><td>+</td><td>1</td><td>+</td><td>s1为空，运算符直接入栈</td></tr><tr><td>(</td><td>1</td><td>+ (</td><td>左括号，直接入栈</td></tr><tr><td>(</td><td>1</td><td>+ ( (</td><td>同上</td></tr><tr><td>2</td><td>1 2</td><td>+ ( (</td><td>数字</td></tr><tr><td>+</td><td>1 2</td><td>+ ( ( +</td><td>s1栈顶为左括号，运算符直接入栈</td></tr><tr><td>3</td><td>1 2 3</td><td>+ ( ( +</td><td>数字</td></tr><tr><td>)</td><td>1 2 3 +</td><td>+ (</td><td>右括号，弹出运算符直至遇到左括号</td></tr><tr><td>×</td><td>1 2 3 +</td><td>+ ( ×</td><td>s1栈顶为左括号，运算符直接入栈</td></tr><tr><td>4</td><td>1 2 3 + 4</td><td>+ ( ×</td><td>数字</td></tr><tr><td>)</td><td>1 2 3 + 4 ×</td><td>+</td><td>右括号，弹出运算符直至遇到左括号</td></tr><tr><td>-</td><td>1 2 3 + 4 × +</td><td>-</td><td>-与+优先级相同，因此弹出+，再压入-</td></tr><tr><td>5</td><td>1 2 3 + 4 × + 5</td><td>-</td><td>数字</td></tr><tr><td>到达最右端</td><td><strong>1 2 3 + 4 × + 5 -</strong></td><td>空</td><td>s1中剩余的运算符</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">polandNotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//将一个中缀表达式转成后缀表达式</span></span><br><span class="line">        <span class="comment">//说明：</span></span><br><span class="line">        <span class="comment">//1. 1+((2+3)×4)-5 转成 1 2 3 + 4 × + 5 –</span></span><br><span class="line">        <span class="comment">//先定义一个逆波兰表达式</span></span><br><span class="line">        <span class="comment">//说明：数字和符号使用空格隔开</span></span><br><span class="line">        <span class="comment">//将得到的中缀表达式转换成后缀表达式对应的list</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">suffixExpression</span> <span class="operator">=</span> <span class="string">&quot;30 4 + 5 * 6 -&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;1+((2+3)*4)-5&quot;</span>;</span><br><span class="line">        List&lt;String&gt; list = toInfixExpressionList(expression);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1.先将suffixExpression放到ArrayList中</span></span><br><span class="line">        <span class="comment">//2.将ArrayList传递一个方法，配合栈完成计算</span></span><br><span class="line">        List&lt;String &gt; epnList = getListString(suffixExpression);</span><br><span class="line">        System.out.println(<span class="string">&quot;epnList&quot;</span>+epnList);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> calculate(epnList);</span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list1 = parseSuffixExpresonList(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;后缀表达式对应的list&quot;</span>);</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编写方法，将中缀表达式，转换成对应的list</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String &gt; toInfixExpressionList(String s)&#123;</span><br><span class="line">        <span class="comment">//定义一个List，存放中缀表达式对应的内容</span></span><br><span class="line">        List&lt;String &gt; ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//这是一个指针，用于遍历中缀表达式字符串</span></span><br><span class="line">        String str;<span class="comment">//做多位数的拼接工作</span></span><br><span class="line">        <span class="type">char</span> c;<span class="comment">//每遍历到一个字符，就放入到c</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//如果c是一个非数字，就加入到ls</span></span><br><span class="line">            <span class="keyword">if</span> ((c=s.charAt(i))&lt;<span class="number">48</span> || (c=s.charAt(i)) &gt; <span class="number">57</span>)&#123;</span><br><span class="line">                ls.add(<span class="string">&quot;&quot;</span>+c);</span><br><span class="line">                i++;<span class="comment">//i后移</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果是一个数，需要考虑多位数问题</span></span><br><span class="line">                str=<span class="string">&quot;&quot;</span>;<span class="comment">//先将string置空</span></span><br><span class="line">                <span class="keyword">while</span> (i&lt;s.length()&amp;&amp;(c=s.charAt(i))&gt;=<span class="number">48</span>&amp;&amp;(c=s.charAt(i))&lt;=<span class="number">57</span>)&#123;</span><br><span class="line">                    str+=c;</span><br><span class="line">                    i++;</span><br><span class="line">                    ls.add(<span class="string">&quot;&quot;</span>+str);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span> (i&lt;s.length());</span><br><span class="line">        <span class="keyword">return</span> ls;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  List&lt;String&gt; <span class="title function_">parseSuffixExpresonList</span><span class="params">(List&lt;String&gt; ls)</span>&#123;</span><br><span class="line">        <span class="comment">//定义两个栈，</span></span><br><span class="line">        Stack&lt;String &gt; s1=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();<span class="comment">//数栈</span></span><br><span class="line">        <span class="comment">//说明：因为s2在整个转换中，没有pop操作，还要逆序,直接使用List&lt;String&gt;</span></span><br><span class="line">        List&lt;String &gt; s2= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//存储结果</span></span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item:ls)&#123;</span><br><span class="line">            <span class="comment">//如果是一个数，就加入到s2</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;</span><br><span class="line">                s2.add(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;)&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!s1.peek().equals(<span class="string">&quot;(&quot;</span>))&#123;<span class="comment">//将与)对应的左括号匹配</span></span><br><span class="line">                   s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                s1.pop();<span class="comment">//将(弹出栈</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当item的优先级小于等于栈顶运算符的优先级</span></span><br><span class="line">                <span class="comment">//我们缺少一个比较优先级高低的方法</span></span><br><span class="line">                <span class="keyword">while</span> ((s1.size()) !=<span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek())&gt;=Operation.getValue(item))&#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//还需要将item压入栈中</span></span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将s1剩余的运算符依次加入s2</span></span><br><span class="line">        <span class="keyword">while</span> (s1.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            s2.add(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2;<span class="comment">//按顺序输出就是对应的逆波兰表达式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getListString</span><span class="params">(String  suffixExpression )</span>&#123;</span><br><span class="line">        <span class="comment">//进行分割</span></span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String &gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String ele:split)&#123;</span><br><span class="line">            list.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成后缀表达式的运算</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(List&lt;String &gt; ls)</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个栈,只需要一个栈即可</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item:ls)&#123;</span><br><span class="line">            <span class="comment">//这里使用正则表达式</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;<span class="comment">//匹配的是多位数</span></span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//pop出两个数并运算,再入栈</span></span><br><span class="line">                <span class="type">int</span> num2=Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> num1=Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (item.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                    res = num1+num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                    res  = num1-num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                   res= num1*num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                  res=  num1/num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把res入栈</span></span><br><span class="line">                stack.push(Integer.toString(res));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后的结果就是栈中的数据</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写一个类,返回一个运算符对应的优先级</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ADD</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SUB</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MUL</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DIV</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，返回对应的优先级数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(String operation)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = ADD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = SUB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = MUL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = DIV;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;不存在该运算符&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h2><p>递归用于解决什么样的问题</p><ol><li>各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google编程大赛)</li><li>各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.</li><li>将用栈解决的问题—&gt;第归代码比较简洁</li></ol><p>递归需要遵守的重要规则</p><ol><li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</li><li>方法的局部变量是独立的，不会相互影响, 比如n变量</li><li>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.</li><li>递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)</li><li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</li></ol><p>简单迷宫的简单问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Recursion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MiGong</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//先创建一个二维数组，模拟迷宫</span></span><br><span class="line">        <span class="comment">//地图</span></span><br><span class="line">        <span class="type">int</span> [][]map=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="comment">//显示有1表示墙</span></span><br><span class="line">        <span class="comment">//上下全部置为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            map[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右置1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            map[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置挡板</span></span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//输出地图</span></span><br><span class="line">        System.out.println(<span class="string">&quot;地图情况&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">7</span>;j++)&#123;</span><br><span class="line">                System.out.print(map[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;走过后&quot;</span>);</span><br><span class="line">        setWay2(map,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//输出新的地图</span></span><br><span class="line">        <span class="comment">//进行标识过的地图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">7</span>;j++)&#123;</span><br><span class="line">                System.out.print(map[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用递归回溯给小球找路</span></span><br><span class="line">    <span class="comment">//说明：map[][]=0为没有走过的路</span></span><br><span class="line">    <span class="comment">//     map[][]为1表示墙，2表示通路可以走，3表示已经走过，但走不通</span></span><br><span class="line">    <span class="comment">//路线：下-&gt;右-&gt;上-&gt;左</span></span><br><span class="line">    <span class="comment">//i，j表示从哪个位置开始找</span></span><br><span class="line">    <span class="comment">//找到通路返回true，不然返回false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">setWay</span><span class="params">(<span class="type">int</span>[][] map,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//按照策略走</span></span><br><span class="line">                map[i][j]=<span class="number">2</span>;<span class="comment">//假定该点可以走通</span></span><br><span class="line">                <span class="keyword">if</span> (setWay(map, i+<span class="number">1</span>, j))&#123;<span class="comment">//向下走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j+<span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i-<span class="number">1</span>, j)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    map[i][j]=<span class="number">3</span>;<span class="comment">//说明走不通，是死路</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上右下左</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">setWay2</span><span class="params">(<span class="type">int</span>[][] map,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//按照策略走</span></span><br><span class="line">                map[i][j]=<span class="number">2</span>;<span class="comment">//假定该点可以走通</span></span><br><span class="line">                <span class="keyword">if</span> (setWay2(map, i-<span class="number">1</span>, j))&#123;<span class="comment">//</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i, j+<span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i+<span class="number">1</span>, j)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i, j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    map[i][j]=<span class="number">3</span>;<span class="comment">//说明走不通，是死路</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="八皇后问题-回溯算法"><a href="#八皇后问题-回溯算法" class="headerlink" title="八皇后问题(回溯算法):"></a>八皇后问题(回溯算法):</h4><ol><li>第一个皇后先放第一行第一列</li><li>第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</li><li>继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解</li><li>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</li><li>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Recursion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EightQueue</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个max</span></span><br><span class="line">    <span class="type">int</span> max=<span class="number">8</span>;</span><br><span class="line">    <span class="comment">//定义数组array，保存皇后的结果</span></span><br><span class="line">    <span class="type">int</span> []array=<span class="keyword">new</span> <span class="title class_">int</span>[max];<span class="comment">//这里需要共享</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">EightQueue</span> <span class="variable">eightQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EightQueue</span>();</span><br><span class="line">        eightQueue.check(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;一共有&quot;</span>+count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置第n个皇后</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == max)&#123;</span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//相当于放第九个皇后</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次放入皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;max;i++)&#123;<span class="comment">//这是判断某一行中的各列问题</span></span><br><span class="line">            <span class="comment">//先把当前皇后n,放到该行的第一列</span></span><br><span class="line">            array[n]=i;</span><br><span class="line">            <span class="comment">//防治第n个皇后到i时，是否冲突</span></span><br><span class="line">            <span class="keyword">if</span> (judge(n))&#123;</span><br><span class="line">                check(n+<span class="number">1</span>);<span class="comment">//不冲突，开始递归</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果冲突，就继续执行array</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看当我们放置第n个皇后时,检测该皇后是否和前面已经摆放的皇后冲突</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> n)</span>&#123;<span class="comment">//n表示第n个皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//Math.abs(array[n]-array[i])==Math.abs(n-i)表示判断斜线上的例子</span></span><br><span class="line">            <span class="keyword">if</span> (array[i]==array[n]||Math.abs(array[n]-array[i])==Math.abs(n-i))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写一个方法，可以将皇后摆放的位置输出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; array.length;i++)&#123;</span><br><span class="line">            System.out.println(array[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="排序："><a href="#排序：" class="headerlink" title="排序："></a>排序：</h2><h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><div class="table-container"><table><thead><tr><th style="text-align:center">常数阶O(1)</th></tr></thead><tbody><tr><td style="text-align:center">对数阶O(log2n)</td></tr><tr><td style="text-align:center">线性阶O(n)</td></tr><tr><td style="text-align:center">线性对数阶O(nlog2n)</td></tr><tr><td style="text-align:center">平方阶O(n^2)</td></tr><tr><td style="text-align:center">立方阶O(n^3)</td></tr><tr><td style="text-align:center">k次方阶O(n^k)</td></tr><tr><td style="text-align:center">指数阶O(2^n)</td></tr></tbody></table></div><p><strong>常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n) ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低</strong></p><p><strong>平均时间复杂度和最坏时间复杂度</strong></p><ol><li>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。</li><li>最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。</li><li>平均时间复杂度和最坏时间复杂度是否一致.</li></ol><p><img src="C:\Users\juan\AppData\Roaming\Typora\typora-user-images\1671346072388.png" alt="1671346072388"></p><p><strong>查看排序算法速度测试代码：</strong></p><p>使用date类的库函数</p><h3 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h3><p>小结冒泡排序规则<br>(1) 一共进行 数组的大小-1 次 大的循环<br>(2)每一趟排序的次数在逐渐的减少<br>(3) 如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> []array=&#123;<span class="number">3</span>,<span class="number">9</span>,-<span class="number">1</span>,<span class="number">10</span>,<span class="number">20</span>&#125;;</span><br><span class="line">        <span class="comment">//为了容易理解，演示过程</span></span><br><span class="line">        <span class="comment">//第一趟排序，将最大的数排在后面</span></span><br><span class="line">        <span class="type">int</span> temp=<span class="number">0</span>;<span class="comment">//临时变量，做交换</span></span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">false</span>;<span class="comment">//定义一个标识变量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; array.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;array.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="comment">//如果前面的数比后面的数大，就交换</span></span><br><span class="line">                <span class="keyword">if</span> (array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    flag=<span class="literal">true</span>;</span><br><span class="line">                    temp=array[j];</span><br><span class="line">                    array[j]=array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;趟的数组&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(array));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="选择排序："><a href="#选择排序：" class="headerlink" title="选择排序："></a>选择排序：</h3><p>选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。</p><ol><li>选择排序一共有 数组大小 - 1 轮排序</li><li>每1轮排序，又是一个循环, 循环的规则(代码)<br>2.1先假定当前这个数是最小数<br>2.2 然后和后面的每个数进行比较，如果发现有比当前数更小的数，就重新确定最小数，并得到下标<br>2.3 当遍历到数组的最后时，就得到本轮最小数和下标<br>2.4 交换 [代码中再继续说 ]</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChoseSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> []arr=&#123;<span class="number">101</span>,<span class="number">34</span>,<span class="number">119</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt; arr.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i]&gt;=arr[j])&#123;</span><br><span class="line">                    temp=arr[i];</span><br><span class="line">                    arr[i]=arr[j];</span><br><span class="line">                    arr[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="插入排序："><a href="#插入排序：" class="headerlink" title="插入排序："></a>插入排序：</h3><p>插入排序（Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> []arr1=&#123;<span class="number">101</span>,<span class="number">34</span>,<span class="number">119</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        Insert(arr1);</span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Insert</span><span class="params">(<span class="type">int</span> []a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> a[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> i-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (insertIndex&gt;=<span class="number">0</span>&amp;&amp;insertVal&lt;a[insertIndex] )&#123;</span><br><span class="line">                <span class="comment">//先将Index后移</span></span><br><span class="line">                a[insertIndex+<span class="number">1</span>]=a[insertIndex];</span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;<span class="comment">//当退出while循环时，找到了插入位置</span></span><br><span class="line">            a[insertIndex+<span class="number">1</span>]=insertVal;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="希尔排序："><a href="#希尔排序：" class="headerlink" title="希尔排序："></a>希尔排序：</h3><p>希尔排序法基本思想</p><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止</p><h4 id="交换式："><a href="#交换式：" class="headerlink" title="交换式："></a><strong>交换式：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> []arr=&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//使用逐步推导的方式</span></span><br><span class="line">        Shell(arr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换式</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Shell</span><span class="params">(<span class="type">int</span> []a)</span>&#123;</span><br><span class="line">        <span class="type">int</span> n= a.length;</span><br><span class="line">        <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n/<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            n=n/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=n;i&lt; a.length;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=i-n;j&gt;=<span class="number">0</span>;j-=n)&#123;<span class="comment">//遍历各组中所有的元素</span></span><br><span class="line">                    <span class="comment">//如果当前元素大于加上步长后的元素</span></span><br><span class="line">                    <span class="keyword">if</span> (a[j]&gt;a[j+n])&#123;</span><br><span class="line">                        temp=a[j];</span><br><span class="line">                        a[j]=a[j+n];</span><br><span class="line">                        a[j+n]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;希尔排序的结果是&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>此种希尔排序极慢，不如移位法，改进成插入式的</strong></p><h4 id="移位法："><a href="#移位法：" class="headerlink" title="移位法："></a>移位法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Shell2</span><span class="params">(<span class="type">int</span> []a)</span>&#123;</span><br><span class="line">        <span class="comment">//增量gap，并逐步缩小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> gap=a.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap=gap/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//从第gap个元素开始，逐个对其所在的组进行直接插入</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=gap;i&lt;a.length;i++)&#123;</span><br><span class="line">                <span class="type">int</span> j=i;</span><br><span class="line">                <span class="type">int</span> temp=a[j];</span><br><span class="line">                <span class="keyword">if</span> (a[j]&lt;a[j-gap])&#123;</span><br><span class="line">                    <span class="keyword">while</span> (j-gap&gt;=<span class="number">0</span>&amp;&amp;temp&lt;a[j-gap])&#123;</span><br><span class="line">                        <span class="comment">//移动</span></span><br><span class="line">                        a[j]=a[j-gap];</span><br><span class="line">                        j-=gap;</span><br><span class="line">                    &#125;</span><br><span class="line">                    a[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;希尔排序的结果是&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h3><p>快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列，<strong>有递归的思想在其中</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr=&#123;<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        quicksort(arr,<span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//left表示左面位置，right表示右边索引位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">//进行判断，如果左边索引比右边索引大，直接return</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义基准数</span></span><br><span class="line">        <span class="comment">//注意基准数一定是灵活的，不是0</span></span><br><span class="line">        <span class="type">int</span> base=arr[left];</span><br><span class="line">        <span class="comment">//定义变量i，指向最左边;i指向最右边</span></span><br><span class="line">        <span class="type">int</span> i=left;</span><br><span class="line">        <span class="type">int</span> j=right;</span><br><span class="line">        <span class="comment">//定义完变量，该开始检索了</span></span><br><span class="line">        <span class="comment">//当i和j不相遇的时候,在循环中进行检索</span></span><br><span class="line">        <span class="keyword">while</span> (i!=j)&#123;</span><br><span class="line">            <span class="comment">//先由j从右往左检索比基准数小的，检索到比基准数小的就停下</span></span><br><span class="line">            <span class="comment">//如果检索到比基准数大的，或者相等的，就继续检索</span></span><br><span class="line">            <span class="keyword">while</span> (arr[j]&gt;=base&amp;&amp;i&lt;j)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//i从左往右检索</span></span><br><span class="line">            <span class="keyword">while</span> (arr[i]&lt;=base&amp;&amp;i&lt;j)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果代码走到这里，i停下j也停下,交换i和j位置的元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i]=arr[j];</span><br><span class="line">            arr[j]=temp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果上面while循环条件不成立，就跳出循环，往下执行</span></span><br><span class="line">        <span class="comment">//如果i和j相遇，就停止检索，交换基准数和相遇位置的元素</span></span><br><span class="line">        <span class="comment">//先把相遇位置的元素赋值给基准数这个位置的元素</span></span><br><span class="line">        arr[left]=arr[i];</span><br><span class="line">        <span class="comment">//把基准数赋值给相遇位置的元素</span></span><br><span class="line">        arr[i]=base;</span><br><span class="line">        <span class="comment">//基准数在这里就归为，左边比他小，右边比他大</span></span><br><span class="line">        <span class="comment">//排基准数的左边,使用递归</span></span><br><span class="line">        quicksort(arr,left,i-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//排右边,也是使用递归</span></span><br><span class="line">        quicksort(arr,i+<span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h3><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="type">int</span> temp[]=<span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        mergeSort(arr,<span class="number">0</span>, arr.length-<span class="number">1</span>,temp );</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分＋合方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span>[] temp)</span>&#123;</span><br><span class="line">        <span class="comment">//先分</span></span><br><span class="line">        <span class="keyword">if</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;<span class="comment">//中间索引</span></span><br><span class="line">            <span class="comment">//向左递归索引</span></span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            <span class="comment">//向右递归进行分解</span></span><br><span class="line">            mergeSort(arr, mid+<span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">//到最后分解的时候</span></span><br><span class="line">            merge(arr,left,mid,right,temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并的方法</span></span><br><span class="line">    <span class="comment">//left是左边有序序列的初始索引</span></span><br><span class="line">    <span class="comment">//mid中间索引</span></span><br><span class="line">    <span class="comment">//right是右边索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> []arr,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right,<span class="type">int</span>[] temp )</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=left;<span class="comment">//左边有序序列的索引</span></span><br><span class="line">        <span class="type">int</span> j= mid+<span class="number">1</span>;<span class="comment">//初始化j，右边有序序列的索引</span></span><br><span class="line">        <span class="type">int</span> t=<span class="number">0</span>;<span class="comment">//指向temp数组的当前索引</span></span><br><span class="line">        <span class="comment">//1.先把左右两边的数据按照规则，填充到temp数组，直到左右两边的有序序列有一边处理完毕为止</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;=mid&amp;&amp;j&lt;=right)&#123;<span class="comment">//判断条件</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i]&lt;=arr[j])&#123;</span><br><span class="line">                temp[t]=arr[i];</span><br><span class="line">                t++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t]=arr[j];</span><br><span class="line">                t++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.把有剩余的数据的一边的数据依次全部填充到temp</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;=mid)&#123;<span class="comment">//左边有序序列还有剩余,就全部填充到temp</span></span><br><span class="line">            temp[t]=arr[i];</span><br><span class="line">            t++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j&lt;=right)&#123;</span><br><span class="line">            temp[t]=arr[j];</span><br><span class="line">            t++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.将temp数组的元素，拷贝到arr</span></span><br><span class="line">        <span class="comment">//注意，不是每次都拷贝所有的</span></span><br><span class="line">        <span class="comment">//是从两个——四个——八个这样子分</span></span><br><span class="line">        t=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tempLeft</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">while</span> (tempLeft&lt;=right)&#123;</span><br><span class="line">            arr[tempLeft] = temp[t];</span><br><span class="line">            t++;</span><br><span class="line">            tempLeft++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="基数排序-桶排序"><a href="#基数排序-桶排序" class="headerlink" title="基数排序(桶排序):"></a>基数排序(桶排序):</h3><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用</p><p>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法</p><p>基数排序(Radix Sort)是桶排序的扩展</p><p>基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。</p><p><strong>基数排序基本思想</strong></p><p>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p><p><strong>基数排序的说明:</strong></p><ol><li>基数排序是对传统桶排序的扩展，速度很快.</li><li>基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError 。</li><li>基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录</li><li></li><li>相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的]</li></ol><h3 id="排序算法对比："><a href="#排序算法对比：" class="headerlink" title="排序算法对比："></a>排序算法对比：</h3><p><img src="C:\Users\juan\AppData\Roaming\Typora\typora-user-images\1671435980065.png" alt="1671435980065"></p><p><img src="C:\Users\juan\AppData\Roaming\Typora\typora-user-images\1671435987819.png" alt="1671435987819"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法(一)</title>
      <link href="/2022/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%B8%80/"/>
      <url>/2022/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法-一"><a href="#数据结构与算法-一" class="headerlink" title="数据结构与算法(一)"></a>数据结构与算法(一)</h1><h2 id="数组与链表"><a href="#数组与链表" class="headerlink" title="数组与链表"></a>数组与链表</h2><p>数据结构包括：线性结构和非线性结构。</p><p>线性结构</p><ol><li><p>线性结构作为最常用的数据结构，其特点是<strong>数据元素之间存在一对一的线性关系</strong></p></li><li><p>线性结构有两种不同的存储结构，即<strong>顺序存储结构和链式存储结构</strong>。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的</p></li><li><p>链式存储的线性表称为链表，链表中的<strong>存储元素不一定是连续的</strong>，元素节点中存放数据元素以及相邻元素的地址信息<br>线性结构常见的有：<strong>数组、队列、链表和栈.</strong></p></li></ol><p>非线性结构</p><ol><li>非线性结构包括：二维数组，多维数组，广义表，树结构，图结构.</li></ol><h3 id="稀疏数组和队列"><a href="#稀疏数组和队列" class="headerlink" title="稀疏数组和队列"></a>稀疏数组和队列</h3><p>因为该二维数组的很多值是默认值0, 因此记录了很多没有意义的数据.-&gt;稀疏数组。</p><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p><p>稀疏数组的处理方法是:</p><ol><li>记录数组一共有几行几列，有多少个不同的值</li><li>把具有不同值的元素的行列及值记录在一个<strong>小规模</strong>的数组中，从而缩小程序的规模</li></ol><p><img src="C:\PictureSource\typora\NN4JIXB$D04_U9SPVBVE@DB.png" alt=""></p><p>二维转稀疏的思路：</p><ol><li>遍历原始的二维数组，得到有效数据的个数sum。</li><li>根据sum可以创建稀疏数组 sparse_Arr int[sum+1] [3]</li><li>将二维数组数据存入到稀疏数组</li></ol><p>稀疏转二维的思路：</p><ol><li>先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</li><li>在读取稀疏数组后几行的数据，并赋给这个原始的二维数组即可。</li></ol><p>二维转稀疏：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建对应的稀疏数组</span></span><br><span class="line">        <span class="type">int</span> sparseArr[][]=<span class="keyword">new</span> <span class="title class_">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//给稀疏数组赋值</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>]=sum;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; <span class="number">11</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">11</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>]=i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>]=j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>]=chessArr1[i][j];</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>稀疏转二维:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.先读出二维数组</span></span><br><span class="line">       <span class="type">int</span> chessArray2[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">       <span class="comment">//2.读取稀疏数组后几行的数据，并且进行赋值</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt; sparseArr.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">               chessArray2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span>[] row:chessArray2)&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> data:row)&#123;</span><br><span class="line">               System.out.printf(<span class="string">&quot;%d\t&quot;</span>,data);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="bug队列"><a href="#bug队列" class="headerlink" title="bug队列"></a>bug队列</h4><ol><li>队列是一个有序列表，可以用数组或是链表来实现。</li><li>遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出<br><img src="C:\Users\juan\AppData\Roaming\Typora\typora-user-images\1671013943016.png" alt="1671013943016"></li></ol><p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 <strong>front及 rear</strong>分别记录队列前后端的下标，<strong>front 会随着数据输出而改变，而 rear则是随着数据输入而改变，</strong></p><p>当我们将数据存入队列时称为<strong>”add_Queue”，add_Queue</strong> 的处理需要有两个步骤：思路分析<br>将尾指针往后移：rear+1 , 当front == rear 【空】<br>若尾指针 rear 小于队列的最大下标 <strong>max_Size -1</strong>，则将数据存入 rear所指的数组元素中，否则无法存入数据。 <strong>rear  == max_Size - 1</strong>[队列满]</p><p>简单队列搭建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">ArrayQueue</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//数组最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;<span class="comment">//指向队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;<span class="comment">//队列尾部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;<span class="comment">//该数组用于存放数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> arrMaxSize)</span>&#123;</span><br><span class="line">        maxSize=arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        front = -<span class="number">1</span>;<span class="comment">//指向队列头部，指向队列头的前一个位置</span></span><br><span class="line">        rear  = -<span class="number">1</span>;<span class="comment">//指向队列尾部，直接指向队列尾部</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断队列满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断队列空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满，不能加入数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rear++;<span class="comment">//让rear后移</span></span><br><span class="line">        arr[rear] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取队列数据,出队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空，不能取数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front++;<span class="comment">//让front后移</span></span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示队列所有数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列空，无数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; arr.length;i++)&#123;</span><br><span class="line">            System.out.println(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示队列头数据，不是取出数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空，无数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[++front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该代码有部分问题，只能进行单次入队，出队，因为头节点和尾节点不会更新，故bug严重</strong></p><h4 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h4><ol><li>尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的时候需要注意 (rear + 1) % max_Size == front 满] </li><li>rear == front [空]</li><li>队列中有效的数据个数为:(rear+max_Size-front)%max_Size</li><li>加入以上算法，即可得出一个环形队列。</li></ol><p><strong>修改后的环形队列：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">ArrayQueue2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//数组最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;<span class="comment">//指向队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;<span class="comment">//队列尾部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;<span class="comment">//该数组用于存放数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue2</span><span class="params">(<span class="type">int</span> arrMaxSize)</span>&#123;</span><br><span class="line">        maxSize=arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        front = <span class="number">0</span>;<span class="comment">//指向队列头部第一个节点</span></span><br><span class="line">        rear  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断队列满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear+<span class="number">1</span>)%maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断队列空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满，不能加入数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接将数据加入</span></span><br><span class="line">        arr[rear]=n;</span><br><span class="line">        <span class="comment">//将rear后移，但注意必须取模</span></span><br><span class="line">        rear=(rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取队列数据,出队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空，不能取数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> s=arr[front];<span class="comment">//临时变量</span></span><br><span class="line">        front=(front+<span class="number">1</span>)%maxSize;<span class="comment">//让front后移</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示队列所有数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列空，无数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从front开始遍历，遍历多少元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=front;i&lt;front+size();i++)&#123;</span><br><span class="line">            System.out.println(arr[i%maxSize]+<span class="string">&quot; &quot;</span>);<span class="comment">//此处可能会产生越界，所以要模</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求出当前队列有效数据的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear+maxSize-front)%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示队列头数据，不是取出数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空，无数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="带头节点的单链表"><a href="#带头节点的单链表" class="headerlink" title="带头节点的单链表"></a>带头节点的单链表</h4><p>链表是有序的列表，但是它在内存中是存储如下</p><p><img src="C:\Users\juan\AppData\Roaming\Typora\typora-user-images\1671066677491.png" alt="1671066677491"></p><ol><li>链表是以节点的方式来存储,是链式存储</li><li>每个节点包含 data 域， next 域：指向下一个节点.</li><li>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定</li></ol><p>单链表实现案例:</p><p><strong>该链表能实现自己进行排序，但依旧是一个较为简陋的链表</strong></p><p>需要按照编号的顺序添加</p><ol><li>首先找到新添加的节点的位置, 是通过辅助变量(指针), 通过遍历来搞定</li><li>新的节点<strong>.next = temp.next</strong></li><li>将 <strong>temp.next = 新的节点</strong></li></ol><p><img src="C:\Users\juan\AppData\Roaming\Typora\typora-user-images\1671071761718.png" alt="1671071761718"></p><p>从单链表中删除一个节点的思路</p><ol><li>我们先找到 需要删除的这个节点的前一个节点 temp</li><li>temp.next = temp.next.next</li><li>被删除的节点，将不会有其它引用指向，会被垃圾回收机制回收</li></ol><p><img src="C:\Users\juan\AppData\Roaming\Typora\typora-user-images\1671072866837.png" alt="1671072866837"></p><p>整个带头节点链表的样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义SingleLinkedList来管理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinked</span>&#123;</span><br><span class="line">    <span class="comment">//先初始化一个头节点，头节点不要动,不存放数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点到单向链表</span></span><br><span class="line">    <span class="comment">//思路：不考虑编号顺序时，</span></span><br><span class="line">    <span class="comment">//1.找到当前链表的最后节点</span></span><br><span class="line">    <span class="comment">//2.将最后这个节点的next指向新节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode heroNode)</span>&#123;</span><br><span class="line">        <span class="comment">//创建辅助变量temp</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有找到最后</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向了链表最后</span></span><br><span class="line">        temp.next=heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种添加的方式，根据排名添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode heroNode)</span>&#123;</span><br><span class="line">        <span class="comment">//因为头节点不能动，仍然通过辅助变量来帮助找到添加的位置</span></span><br><span class="line">        <span class="comment">//单链表，因此找的temp是位于 添加位置的前一个节点，否则插入不了</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//标志添加的编号是否存在，默认false</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//到达链表最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no&gt;heroNode.no)&#123;</span><br><span class="line">                <span class="comment">//位置找到，在temp后面</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no)&#123;</span><br><span class="line">                <span class="comment">//说明希望添加的编号已然存在</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断flag的值</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;<span class="comment">//不能添加，编号存在</span></span><br><span class="line">            System.out.println(<span class="string">&quot;准备插入的英雄编号存在，不能加入&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入到链表中，temp的后面</span></span><br><span class="line">            heroNode.next=temp.next;</span><br><span class="line">            temp.next=heroNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改节点的信息,根据编号来修改，即no编号不能改</span></span><br><span class="line">    <span class="comment">//1.根据newHeroNode的no来修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode heroNode)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到需要修改的节点,根据no</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//此处表示是否找到</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//到链表最后了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no== heroNode.no)&#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断是否找到要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            temp.name=heroNode.name;</span><br><span class="line">            temp.nickname= heroNode.nickname;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到这个节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因此需要一个辅助变量来遍历</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//最后要后移</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Delete</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;头节点为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode temp=head;</span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no==no)&#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            temp.next=temp.next.next;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到，无法删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个HeroNode,每个HeroNode对象都是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;<span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示方法，直接重写toString方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickname=&#x27;&quot;</span> + nickname + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单链表的常见面试题有如下:<br>求单链表中有效节点的个数<br>查找单链表中的倒数第k个结点<br>单链表的反转<br>从尾到头打印单链表 【要求方式1：反向遍历 。 方式2：Stack栈】<br>合并两个有序的单链表，合并之后的链表依然有序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用栈从尾到头打印</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(HeroNode head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="literal">null</span>||head.next.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个栈,压入各个节点</span></span><br><span class="line">        Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//将链表的所有节点压入栈中</span></span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行打印</span></span><br><span class="line">        <span class="keyword">while</span> (stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(stack.pop());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将单链表反转</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversetList</span><span class="params">(HeroNode head)</span>&#123;</span><br><span class="line">        <span class="comment">//如果当前链表为空，或者只有一个节点，无需反转，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="literal">null</span>||head.next.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义一个辅助的指针，帮助我们遍历原来的链表</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//指向cur的下一个节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历原来的链表</span></span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next=reverseHead.next;<span class="comment">//将cur的下一个节点指向新链表的最前端</span></span><br><span class="line">            reverseHead.next=cur;</span><br><span class="line">            cur = next;<span class="comment">//让cur后移</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        head.next=reverseHead.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">findLastNode</span><span class="params">(HeroNode head,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> sum(head);</span><br><span class="line">        <span class="comment">//遍历到size-index位置，就是倒数第k个</span></span><br><span class="line">        <span class="comment">//先进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span>||index &gt;size)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义辅助变量,指向第一个节点</span></span><br><span class="line">        HeroNode cur=head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;size-index;i++)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。<br>单向链表<strong>不能自我删除，需要靠辅助节点</strong> ，而双向链表，<strong>则可以自我删除</strong>，所以前面我们单链表删除时节点，总是找到temp<strong>,temp是待删除节点的前一个节点</strong>(<del>认真体会</del>).</p><p>分析 双向链表的遍历，添加，修改，删除的操作思路===》代码实现<br>1) 遍历 方和 单链表一样，只是可以向前，也可以向后查找<br>2) 添加 (默认添加到双向链表的最后)<br>(1) 先找到双向链表的最后这个节点<br>(2) temp.next = newHeroNode<br>(3) newHeroNode.pre = temp;<br>3) 修改 思路和 原来的单向链表一样.<br>4) 删除<br>(1) 因为是双向链表，因此，我们可以实现自我删除某个节点<br>(2) 直接找到要删除的这个节点，比如temp<br>(3)  temp.pre.next = temp.next<br>(4) temp.next.pre = temp.pre;</p><p><strong>注意：下面为整段代码，大致是在单链表的基础上加以修改而来</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//搭建一个双向链表的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleLinkedList2</span>&#123;</span><br><span class="line">    <span class="comment">//先初始化一个头节点，头节点不要动,不存放数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">DoubleHeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//返回头节点</span></span><br><span class="line">    <span class="keyword">public</span> DoubleHeroNode <span class="title function_">getHead</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历直接套用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因此需要一个辅助变量来遍历</span></span><br><span class="line">        <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//最后要后移</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个节点到双向链表的最后</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(DoubleHeroNode heroNode)</span>&#123;</span><br><span class="line">        <span class="comment">//创建辅助变量temp</span></span><br><span class="line">        <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有找到最后</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向了链表最后</span></span><br><span class="line">        <span class="comment">//形成一个双向链表</span></span><br><span class="line">        temp.next=heroNode;</span><br><span class="line">        heroNode.pre=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改一个节点的内容,双向链表的节点内容修改和单向链表一样</span></span><br><span class="line">    <span class="comment">//只是节点类型改成DoubleHeroNode</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(DoubleHeroNode heroNode)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到需要修改的节点,根据no</span></span><br><span class="line">        <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//此处表示是否找到</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//到链表最后了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no== heroNode.no)&#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断是否找到要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            temp.name=heroNode.name;</span><br><span class="line">            temp.nickname= heroNode.nickname;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到这个节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从双向链表中删除一个节点</span></span><br><span class="line">    <span class="comment">//说明：</span></span><br><span class="line">    <span class="comment">//1.对于双向链表，我们可以直接找到要删除的这个节点</span></span><br><span class="line">    <span class="comment">//2.找到后，自我删除即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Delete</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="comment">//判断当前链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;头节点为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        DoubleHeroNode temp=head.next;</span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no==no)&#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            temp.pre.next=temp.next;</span><br><span class="line">            <span class="comment">//不加上条件判断，无法进行删除尾节点的操作</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next!=<span class="literal">null</span>) &#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到，无法删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义表头</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleHeroNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> DoubleHeroNode next;<span class="comment">//指向下一个节点,默认为null</span></span><br><span class="line">    <span class="keyword">public</span> DoubleHeroNode pre;<span class="comment">//指向前一个节点，默认为null</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoubleHeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示方法，直接重写toString方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickname=&#x27;&quot;</span> + nickname + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>按顺序，能够判断在链表结尾和链表中间的加入方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(DoubleHeroNode heroNode)</span>&#123;</span><br><span class="line">        <span class="comment">//因为头节点不能动，仍然通过辅助变量来帮助找到添加的位置</span></span><br><span class="line">        <span class="comment">//单链表，因此找的temp是位于 添加位置的前一个节点，否则插入不了</span></span><br><span class="line">        <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//标志添加的编号是否存在，默认false</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//到达链表最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no&gt;heroNode.no)&#123;</span><br><span class="line">                <span class="comment">//位置找到，在temp后面</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no)&#123;</span><br><span class="line">                <span class="comment">//说明希望添加的编号已然存在</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断flag的值</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;<span class="comment">//不能添加，编号存在</span></span><br><span class="line">            System.out.println(<span class="string">&quot;准备插入的英雄编号存在，不能加入&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入到链表中，temp的后面</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                heroNode.next=temp.next;</span><br><span class="line">                temp.next.pre=heroNode;</span><br><span class="line">                temp.next=heroNode;</span><br><span class="line">                heroNode.pre=temp;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next=heroNode;</span><br><span class="line">                heroNode.pre=temp.next;</span><br><span class="line">                heroNode.next=<span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客关键字查询以及Typora使用指南</title>
      <link href="/2022/12/13/Hexo%E5%8D%9A%E5%AE%A2%E5%85%B3%E9%94%AE%E5%AD%97%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8ATypora%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2022/12/13/Hexo%E5%8D%9A%E5%AE%A2%E5%85%B3%E9%94%AE%E5%AD%97%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8ATypora%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo博客关键字查询以及Typora使用指南"><a href="#Hexo博客关键字查询以及Typora使用指南" class="headerlink" title="Hexo博客关键字查询以及Typora使用指南"></a>Hexo博客关键字查询以及Typora使用指南</h1><h2 id="Hexo开头关键词"><a href="#Hexo开头关键词" class="headerlink" title="Hexo开头关键词"></a>Hexo开头关键词</h2><p><strong>对于Hexo博客的搭建，可以使用以下关键词用于页面设计：</strong></p><blockquote><p>Page Front-matter 用于页面配置</p><p>Post Front-matter 用于文章页配置</p></blockquote><p> <strong>Page Front-matter：</strong> </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: #页面标题</span><br><span class="line">date: #页面创建日期</span><br><span class="line">updated: #页面更新日期</span><br><span class="line">type: #标签、分类和友情链接三个页面需要配置</span><br><span class="line">comments: #显示页面评论模块(默认 true)</span><br><span class="line">description: #页面描述</span><br><span class="line">keywords: #页面关键字</span><br><span class="line">top<span class="emphasis">_img: #页面顶部图片</span></span><br><span class="line"><span class="emphasis">mathjax: #显示mathjax(当设置mathjax的per_</span>page: false时，才需要配置，默认 false)</span><br><span class="line">katex: #显示katex(当设置katex的per<span class="emphasis">_page: false时，才需要配置，默认 false)</span></span><br><span class="line"><span class="emphasis">aside: #显示侧边栏 (默认 true)</span></span><br><span class="line"><span class="emphasis">aplayer: #在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink: #配置代码框是否展开(true/false)(默认为设置中highlight<span class="emphasis">_shrink的配置)</span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure><p> <strong>Post Front-matter：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img:</span><br><span class="line">comments:</span><br><span class="line">cover:</span><br><span class="line">toc:</span><br><span class="line">toc_number:</span><br><span class="line">toc_style_simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright_author:</span><br><span class="line">copyright_author_href:</span><br><span class="line">copyright_url:</span><br><span class="line">copyright_info:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">aside:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】文章标题</td></tr><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated</td><td>【可选】文章更新日期</td></tr><tr><td>tags</td><td>【可选】文章标籤</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认 true)</td></tr><tr><td>toc</td><td>【可选】显示文章TOC(默认为设置中toc的enable配置)</td></tr><tr><td>toc_number</td><td>【可选】显示toc_number(默认为设置中toc的number配置)</td></tr><tr><td>toc_style_simple</td><td>【可选】显示 toc 简洁模式</td></tr><tr><td>copyright</td><td>【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</td></tr><tr><td>copyright_author</td><td>【可选】文章版权模块的文章作者</td></tr><tr><td>copyright_author_href</td><td>【可选】文章版权模块的文章作者链接</td></tr><tr><td>copyright_url</td><td>【可选】文章版权模块的文章连结链接</td></tr><tr><td>copyright_info</td><td>【可选】文章版权模块的版权声明文字</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr></tbody></table></div><hr><h2 id="Typora使用指南"><a href="#Typora使用指南" class="headerlink" title="Typora使用指南"></a>Typora使用指南</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>Markdown</strong> 是一种轻量型标记语言, 是一种语法. 以 <code>.md</code> 结尾的文本文件就是 Markdown 文件. 相较于 <strong>Word</strong>, 它更加像是 <strong>HTML</strong> 语言或是 LATEX, 并不是最淳朴的那种”所见即所得”. 它处处透露着一种极简主义. 高效简洁清晰的同时, 又很简单. 看起来舒服, 语法简单, 尤其在处理纯文本上有很大的优势.</p><p>它相较于 <strong>Word</strong>, 兼容性非常高, 可以跨平台使用, 不用担心奇奇怪怪的版本兼容问题. 同时, 有许多网站都支持或正在使用 <strong>Markdown</strong> 语法. 如 <strong>Github</strong> (等一系列代码托管平台), StackOverflow(等答疑平台), 简书, 语雀 (等一系列笔记平台).<del>博主通过py交易才整到软件捏</del></p><p>ps：该博客中大部分笔记主要参考了<a href="[Sakiyary/Markdown-Typora-VSCode-Doc: 视频解说请上 Bilibili 观看 (github.com">这个网址</a>](<a href="https://github.com/Sakiyary/Markdown-Typora-VSCode-Doc">https://github.com/Sakiyary/Markdown-Typora-VSCode-Doc</a>) )捏</p><p><strong>所有想写的东西，包括笔记，日记什么的都可以用markdown写！</strong></p><h3 id="0-写-Markdown-的第零步"><a href="#0-写-Markdown-的第零步" class="headerlink" title="0. 写 Markdown 的第零步"></a>0. 写 Markdown 的第零步</h3><p>我们写文本的时候大多写的是中文, 可是输入法在输中文时使用的标点为全角标点, 如 <code>，。？！（）【】：；“”</code>. 这些标点是不被 Markdown 所认可的, 也是无法转义的.</p><p>我建议大家写 Markdown 的时候都用半角标点, 即英文标点, 如 <code>,.?!()[]:;&quot;&quot;</code>. 且每个半角标点在文本使用时加上后置空格, 符合英文标点的书写规范, 也更加美观.</p><p>以微软自带输入法举例, 在使用中文输入法时按下 <code>Ctrl</code> + <code>.(这是个句号)</code>, 切换标点的全角与半角. 这样即可中文输入+半角标点.</p><h3 id="1-标题-数个-“-”-空格-前置"><a href="#1-标题-数个-“-”-空格-前置" class="headerlink" title="1. 标题 [数个 “#” + 空格 前置]"></a>1. 标题 [数个 “#” + 空格 前置]</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><p>标题会在目录与大纲分级显示, 可以跳转.</p><p>在 Typora 中建议开启 <code>严格模式</code>, 即不应为 <code>#标题</code>, 应为 <code># 标题</code>.</p><p>应该要手动补上空格, 使得 Markdown 语法在其他文本编辑器上兼容.</p><h3 id="2-强调-用-“-”-或-“-”-包围"><a href="#2-强调-用-“-”-或-“-”-包围" class="headerlink" title="2. 强调 [用 “**” 或 “__” 包围]"></a>2. 强调 [用 “**” 或 “__” 包围]</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**欢迎报考中国矿业大学**</span></span><br><span class="line"><span class="strong">__欢迎报考中国矿业大学__</span></span><br></pre></td></tr></table></figure><p>例：<strong>欢迎报考中国矿业大学</strong></p><h3 id="4-删除线-用-“-”-包围"><a href="#4-删除线-用-“-”-包围" class="headerlink" title="4. 删除线 [用 “~~” 包围]"></a>4. 删除线 [用 “~~” 包围]</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~我宣布个事啊~~</span><br></pre></td></tr></table></figure><h3 id="5-高亮-用-“-”-包围"><a href="#5-高亮-用-“-”-包围" class="headerlink" title="5. *高亮 [用 “==” 包围]"></a>5. *高亮 [用 “==” 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">==颜色很好看==</span><br></pre></td></tr></table></figure><h3 id="6-代码-用-“-”-包围"><a href="#6-代码-用-“-”-包围" class="headerlink" title="6. 代码 [用 “`” 包围]"></a>6. 代码 [用 “`” 包围]</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`sudo rm -rf /*`</span></span><br></pre></td></tr></table></figure><p>E.G.</p><p><code>sudo rm -rf /*</code> (没事别乱敲这个! )</p><p><del>“请输入管理员密码: (闪烁的光标)”</del></p><h3 id="7-代码块-按三个-“-”-并敲回车"><a href="#7-代码块-按三个-“-”-并敲回车" class="headerlink" title="7. 代码块 [按三个 “`” 并敲回车]"></a>7. 代码块 [按三个 “`” 并敲回车]</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```</span></span><br><span class="line"><span class="code">// 这里就可以开始输入你要的代码了</span></span><br><span class="line"><span class="code">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="code">int mian() &#123;</span></span><br><span class="line"><span class="code">    print（“Hello, world!\n&quot;）;</span></span><br><span class="line"><span class="code">    retrun O;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">``` </span>// (这三个&quot;`&quot;文本编辑器会帮你自动补全 一般不用手动输)</span><br></pre></td></tr></table></figure><p>(我之前都是用这个来展示各种语法的, 应该不用举例了吧)</p><p>要想显示行数的话, 一般要在 Typora 的设置里勾上这个显示行数的选项.</p><p>代码块里可以选择语言, 其会根据语言来自动高亮各个语句. 在选择语言后, <code>```` 会变为 `````` +</code>对应语言`.</p><h3 id="8-引用-“-gt-”-空格-前置"><a href="#8-引用-“-gt-”-空格-前置" class="headerlink" title="8. 引用 [“&gt;” + 空格 前置]"></a>8. 引用 [“&gt;” + 空格 前置]</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 24岁, 是学生.</span></span><br><span class="line"><span class="quote">&gt; &gt; 学生特有的无处不在(恼)</span></span><br></pre></td></tr></table></figure><p>引用是可以嵌套的,可以产生多重引用</p><h3 id="9-无序列表-“-“-或-“-”-空格-前置"><a href="#9-无序列表-“-“-或-“-”-空格-前置" class="headerlink" title="9. 无序列表 [“-“ 或 “+” + 空格 前置]"></a>9. 无序列表 [“-“ 或 “+” + 空格 前置]</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 一颗是枣树 (我喜欢用这种)</span><br><span class="line"><span class="bullet">+</span> 另一颗还是枣树</span><br><span class="line"><span class="bullet">*</span> (其实这种也可以, 不过由于在 Typora 中很难单个输入, 故不常用)</span><br></pre></td></tr></table></figure><p>三种前置符都可以, 敲回车会自动补全, 可在 Typora 设置中调整补全的符号, 敲回车后按下 <code>Tab</code> 会缩进一级.</p><p>例：</p><ul><li>一颗枣树</li><li>另一颗也是枣树</li></ul><h3 id="10-有序列表-数字-“-”-空格-前置"><a href="#10-有序列表-数字-“-”-空格-前置" class="headerlink" title="10. 有序列表 [数字 + “.” + 空格 前置]"></a>10. 有序列表 [数字 + “.” + 空格 前置]</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我来这里就为了三件事:</span><br><span class="line"><span class="bullet">1.</span> 公平</span><br><span class="line"><span class="bullet">2.</span> 公平</span><br><span class="line"><span class="bullet">3.</span> 还是tm的公平!</span><br></pre></td></tr></table></figure><p>敲回车会自动补全, 敲回车后按下 <code>Tab</code> 会缩进一级.</p><p>例子：</p><ol><li>公平</li><li>公平</li><li>还是tm的公平</li></ol><h3 id="11-上标-用-“-”-包围"><a href="#11-上标-用-“-”-包围" class="headerlink" title="11. *上标 [用 “^” 包围]"></a>11. *上标 [用 “^” 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中int的上限是 2^31^ - 1 = 2147483647</span><br></pre></td></tr></table></figure><h3 id="12-下标-用-“-”-包围"><a href="#12-下标-用-“-”-包围" class="headerlink" title="12. *下标 [用 “~” 包围]"></a>12. *下标 [用 “~” 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H~2~O 是剧毒的!</span><br></pre></td></tr></table></figure><p>例子： H~2~o</p><h3 id="13-注释-“-后置"><a href="#13-注释-“-后置" class="headerlink" title="13. *注释 [“]" 后置"></a>13. *注释 [“<sup><a href="#fn_]" 后置" id="reffn_]" 后置">]" 后置</a></sup></h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 今日我们相聚于此, 是为了学习 Markdown 的使用, 它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励![^1]</span></span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">沃兹·基·硕德 改编自「公鸡」普契涅拉.</span></span><br></pre></td></tr></table></figure><p>大多数时候，注释对应内容事写在最底下的</p><blockquote><p>今日我们相聚于此, 是为了学习 Markdown 的使用, 它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励<sup><a href="#fn_1" id="reffn_1">1</a></sup></p><blockquote id="fn_1"><sup>1</sup>. 沃兹·基·硕德 改编自「公鸡」普契涅拉.<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote></blockquote><h3 id="链接-常用-“-”-“-”-分别包围文本与链接"><a href="#链接-常用-“-”-“-”-分别包围文本与链接" class="headerlink" title="链接 [常用 “[ ]” + “( )” 分别包围文本与链接]"></a>链接 [常用 “[ ]” + “( )” 分别包围文本与链接]</h3><p><strong>(注意: 文内跳转为扩展用法)</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">来看看我贫瘠的网站罢</span>](<span class="link">https://www.songhuangzhushang.cn/</span>)</span><br><span class="line">[<span class="string">基础教程: 12. 下标</span>](<span class="link">#12. 下标 [用 &quot;~&quot; 包围]</span>)</span><br></pre></td></tr></table></figure><p>支持网页链接与文内跳转, 按住 <code>Ctrl</code> 并 <code>单击鼠标左键</code> 即可跳转.</p><h3 id="15-任务列表-“-”-空格-前置"><a href="#15-任务列表-“-”-空格-前置" class="headerlink" title="15. 任务列表 [“- [ ]” + 空格 前置]"></a>15. 任务列表 [“- [ ]” + 空格 前置]</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TodoList:</span><br><span class="line"><span class="bullet">-</span> [ ] 刷B站</span><br><span class="line"><span class="bullet">-</span> [ ] 写代码</span><br><span class="line"><span class="bullet">-</span> [x] 起床</span><br></pre></td></tr></table></figure><p>用 <code>x</code> 代替 <code>[ ]</code> 中的空格来勾选任务列表. 在 Typora 中可以直接用鼠标左键单击勾选框.</p><p>例： </p><p>​      TodoList: </p><ul><li>[ ]   刷B站</li><li>[ ] 写代码</li><li>[x] 起床</li></ul><h3 id="16-表格-用-“-”-绘制表格边框"><a href="#16-表格-用-“-”-绘制表格边框" class="headerlink" title="16. 表格 [用 “|” 绘制表格边框]"></a>16. 表格 [用 “|” 绘制表格边框]</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 学号 | 姓名  | 年龄 |</span><br><span class="line">| :--- | :---: | ---: | (引号的位置代表着 左对齐, 居中, 右对齐)</span><br><span class="line">|114514|田所|24|</span><br><span class="line">|1919810|浩三|25|</span><br></pre></td></tr></table></figure><p>第一行为表头, 并由第二行分割线决定对齐方式与长度, 第三行及之后即表格数据</p><div class="table-container"><table><thead><tr><th style="text-align:center">学号</th><th style="text-align:center">姓名</th><th style="text-align:center">年龄</th></tr></thead><tbody><tr><td style="text-align:center">114514</td><td style="text-align:center">田所</td><td style="text-align:center">24</td></tr><tr><td style="text-align:center">1919810</td><td style="text-align:center">浩三</td><td style="text-align:center">25</td></tr></tbody></table></div><h3 id="17-图片-直接拖进来或者复制粘贴"><a href="#17-图片-直接拖进来或者复制粘贴" class="headerlink" title="17. 图片 [直接拖进来或者复制粘贴]"></a>17. 图片 [直接拖进来或者复制粘贴]</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">图片</span>](<span class="link">图片的位置</span>)</span><br></pre></td></tr></table></figure><p>我还是会选择拖进来或者复制粘贴啦~ 在 Typora 的设置里也可以改图片的储存方式.</p><h3 id="18-分割线-按三个-“-”-或-“-“-或-“-”-并敲回车"><a href="#18-分割线-按三个-“-”-或-“-“-或-“-”-并敲回车" class="headerlink" title="18. 分割线 [按三个 “*” 或 “-“ 或 “_” 并敲回车]"></a>18. 分割线 [按三个 “*” 或 “-“ 或 “_” 并敲回车]</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">***</span></span><br><span class="line"><span class="strong">--- </span></span><br><span class="line"><span class="strong">___</span></span><br><span class="line"><span class="strong">// (其实按三个及以上都可以)</span></span><br></pre></td></tr></table></figure><h2 id="Typora进阶教程"><a href="#Typora进阶教程" class="headerlink" title="Typora进阶教程"></a>Typora进阶教程</h2><h3 id="1-目录-自动生成"><a href="#1-目录-自动生成" class="headerlink" title="1. 目录 [自动生成]"></a>1. 目录 [自动生成]</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TOC] (此为 Typora 特有的, 如本文档开头)</span><br></pre></td></tr></table></figure><p>若使用 VS Code 搭配 Markdown All in One 扩展, 可在 VS Code 的<code>命令面板</code> (即 <a href="https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette">VS Code Command Palette</a>) 输入 <code>Create Table of Contents</code> 自动生成目录, 且可在扩展设置中细调目录参数.</p><h3 id="2-内联-HTML-代码-用-“-“-包围"><a href="#2-内联-HTML-代码-用-“-“-包围" class="headerlink" title="2. 内联 HTML 代码 [用 “ “ 包围]"></a>2. 内联 HTML 代码 [用 “<> </>“ 包围]</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center&quot;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span></span>我不会 HTML 呜呜呜... 浇浇我<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span>简单的文字居中也可以这样<span class="language-xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>我差点忘了还有下划线这东西...<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>只要你会写, 你完全可以把 Markdown 当作 <strong>HTML</strong> 来写.</p><p>同时, <code>.md</code> 文件可以直接导出成一个网页.</p><p>下划线可以选中想要下划的文字按下 <code>Ctrl</code> + <code>U</code>.</p><h3 id="3-内联-LATEX-公式-用-“-”-包围"><a href="#3-内联-LATEX-公式-用-“-”-包围" class="headerlink" title="3. 内联 LATEX 公式 [用 “$” 包围]"></a>3. 内联 LATEX 公式 [用 “$” 包围]</h3><p><strong>(注意: 部分编译器会不识别部分符号)</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$\LaTeX$ 是最好用的论文排版语言! 不信你看!</span><br><span class="line"></span><br><span class="line">$a^n+b^n=c^n$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">%\usepackage&#123;unicode-math&#125;</span><br><span class="line">\displaystyle \ointctrclockwise\mathcal&#123;D&#125;[x(t)]</span><br><span class="line">\sqrt&#123;\frac&#123;\displaystyle3\uppi^2-\sum<span class="emphasis">_&#123;q=0&#125;^&#123;\infty&#125;(z+\hat L)^&#123;q&#125;</span></span><br><span class="line"><span class="emphasis">\exp(\symrm&#123;i&#125;q^2 \hbar x)&#125;&#123;\displaystyle (\symsfup&#123;Tr&#125;\symbfcal&#123;A&#125;)</span></span><br><span class="line"><span class="emphasis">\left(\symbf\Lambda_</span>&#123;j<span class="emphasis">_1j_</span>2&#125;^&#123;i<span class="emphasis">_1i_</span>2&#125;\Gamma<span class="emphasis">_&#123;i_</span>1i<span class="emphasis">_2&#125;^&#123;j_</span>1j<span class="emphasis">_2&#125;</span></span><br><span class="line"><span class="emphasis">\hookrightarrow\vec D\cdot \symbf P \right)&#125;&#125;</span></span><br><span class="line"><span class="emphasis">=\underbrace&#123;\widetilde&#123;\left\langle \frac&#123;\notin \emptyset&#125;</span></span><br><span class="line"><span class="emphasis">&#123;\varpi\alpha_</span>&#123;k\uparrow&#125;&#125;\middle\vert</span><br><span class="line">\frac&#123;\partial<span class="emphasis">_\mu T_</span>&#123;\mu\nu&#125;&#125;&#123;2&#125;\right\rangle&#125;&#125;<span class="emphasis">_&#123;\mathrm&#123;K&#125;_</span>3</span><br><span class="line">\mathrm&#123;Fe&#125;(\mathrm&#123;CN&#125;)<span class="emphasis">_6&#125; ,\forall z \in \mathbb&#123;R&#125;</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><p>用 <script type="math/tex">` 包围为单条公式, 按下两个 `</script> 并敲回车即生成公式块.</p><p>可以形成公式，写论文会很有用。</p><h3 id="4-网络图床"><a href="#4-网络图床" class="headerlink" title="4. *网络图床"></a>4. *网络图床</h3><p>(还没实践，日后使用图床时候再使用.)</p><p>分享一个 Typora 搭配腾讯云COS/阿里云OSS图床的<a href="https://blog.csdn.net/guo_ridgepole/article/details/108257277">例子</a>. 新用户免费试用6个月, 另外还可选择七牛云或者路过图床.</p><h3 id="5-Typora-的常用快捷键"><a href="#5-Typora-的常用快捷键" class="headerlink" title="5. *Typora 的常用快捷键"></a>5. *Typora 的常用快捷键</h3><div class="table-container"><table><thead><tr><th>按键</th><th>效果</th><th>按键</th><th>效果</th></tr></thead><tbody><tr><td><code>Ctrl</code> + <code>D</code></td><td>选中当前词</td><td><code>Ctrl</code> + <code>L</code></td><td>选中当前句/行</td></tr><tr><td><code>Ctrl</code> + <code>E</code></td><td>选中当前区块</td><td><code>Ctrl</code> + <code>F</code></td><td>搜索当前选中</td></tr><tr><td><code>Ctrl</code> + <code>B</code></td><td>加粗当前选中</td><td><code>Ctrl</code> + <code>H</code></td><td>替换当前选中</td></tr><tr><td><code>Ctrl</code> + <code>I</code></td><td>倾斜当前选中</td><td><code>Ctrl</code> + <code>U</code></td><td>下划当前选中</td></tr><tr><td><code>Ctrl</code> + <code>K</code></td><td>将当前选中生成链接</td><td><code>Ctrl</code> + <code>J</code></td><td>滚动屏幕将选中滚至顶部</td></tr><tr><td><code>Ctrl</code> + <code>W</code></td><td>关闭当前窗口</td><td><code>Ctrl</code> + <code>N</code></td><td>打开新窗口</td></tr><tr><td><code>Ctrl</code> + <code>O</code></td><td>打开文件</td><td><code>Ctrl</code> + <code>P</code></td><td>搜索文件并打开</td></tr><tr><td><code>Ctrl</code> + <code>回车</code></td><td>表格下方插入行</td><td><code>Ctrl</code> + <code>,</code></td><td>打开偏好设置</td></tr><tr><td><code>Ctrl</code> + <code>.</code></td><td>切换全角/半角标点</td><td><code>Ctrl</code> + <code>/</code></td><td>切换正常/源代码视图</td></tr><tr><td><code>Ctrl</code> + <code>Shift</code> + <code>-</code></td><td>缩小视图缩放</td><td><code>Ctrl</code> + <code>Shift</code> + <code>+</code></td><td>放大视图缩放</td></tr></tbody></table></div><p>还有一些不常用的/三键的快捷键不在此列出.</p><hr>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第四篇文章</title>
      <link href="/2022/12/13/H1/"/>
      <url>/2022/12/13/H1/</url>
      
        <content type="html"><![CDATA[<p>[Toc]</p><h1 id="H1"><a href="#H1" class="headerlink" title="H1"></a>H1</h1><p><strong>欢迎报考中国矿业大学</strong></p><p>欢迎大佬教学</p><p><del>我宣布格式</del></p><p>==我什么颜色都喜欢==</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-id">#nav</span> <span class="selector-class">.site-page</span>,</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-id">#nav</span> <span class="selector-class">.menus_items</span> <span class="selector-class">.menus_item</span> <span class="selector-class">.menus_item_child</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">2px</span> <span class="built_in">var</span>(--theme-color) <span class="meta">!important</span>;</span><br></pre></td></tr></table></figure><blockquote><p>19岁，是学生</p><p>烦恼无处不在</p></blockquote><ul><li><p>一颗枣树</p></li><li><p>还是一颗枣树</p></li></ul><blockquote><p>今日份的笔记是为了更好的摸鱼<sup><a href="#fn_1" id="reffn_1">1</a></sup></p></blockquote><blockquote id="fn_1"><sup>1</sup>. 沃兹改编自【公鸡】<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><p><a href="[Juan - 这是我的一个小小基地 (songhuangzhushang.cn">这是我的网站</a>](<a href="https://www.songhuangzhushang.cn/">https://www.songhuangzhushang.cn/</a>) )</p><p><img src="C:\PictureSource\animation-Animation-Lee-2199987-wallhere.com.jpg" alt=""></p><div style="text-align:center">  <font style="color:red">我不会 HTML 呜呜呜... 浇浇我</font></div><p><center>简单的文字居中也可以这样</center></p><script type="math/tex; mode=display">$a^n+b^n=c^n$</script>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第二篇文章</title>
      <link href="/2022/12/11/%E7%AC%AC%E4%BA%8C%E7%AF%87/"/>
      <url>/2022/12/11/%E7%AC%AC%E4%BA%8C%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第二篇文章"><a href="#这是我的第二篇文章" class="headerlink" title="这是我的第二篇文章"></a>这是我的第二篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第三篇文章</title>
      <link href="/2022/12/11/NULL/"/>
      <url>/2022/12/11/NULL/</url>
      
        <content type="html"><![CDATA[<h1 id="Hi"><a href="#Hi" class="headerlink" title="Hi"></a>Hi</h1>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/2022/12/11/2022-12-9-%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
      <url>/2022/12/11/2022-12-9-%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }  /* CDN 服务仅供平台体验和调试使用，平台不承诺服务的稳定性，企业客户需下载字体包自行发布使用并做好备份。 */@font-face {  font-family: "YSHST";src: url("//at.alicdn.com/wf/webfont/YOVbS2DI1sZr/OxL8VSlThT5xIdDONo99F.woff2") format("woff2"),  url("//at.alicdn.com/wf/webfont/YOVbS2DI1sZr/HPFFcikz9zmabL2zlMcr6.woff") format("woff");  font-display: swap;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}/* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(5) .menus_item_child {  left: -38px;}/* 夜间模式菜单栏发光字 */[data-theme] #nav .site-page,[data-theme] #nav .menus_items .menus_item .menus_item_child li a {  text-shadow: 0 0 2px var(rgb(91, 19, 133)) !important;}/* 手机端适配 */[data-theme="dark"] #sidebar #sidebar-menus .menus_items .site-page {  text-shadow: 0 0 2px var(rgb(179, 71, 241)) !important;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #22222496;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}/* 鼠标样式 */#cursor {  position: fixed;  width: 16px;  height: 16px;  /* 这里改变跟随的底色 */  background: rgb(240, 38, 65);  border-radius: 8px;  opacity: 0.25;  z-index: 10086;  pointer-events: none;  transition: 0.2s ease-in-out;  transition-property: background, opacity, transform;}#cursor.hidden {  opacity: 0;}#cursor.hover {  opacity: 0.1;  transform: scale(2.5);  -webkit-transform: scale(2.5);  -moz-transform: scale(2.5);  -ms-transform: scale(2.5);  -o-transform: scale(2.5);}#cursor.active {  opacity: 0.5;  transform: scale(0.5);  -webkit-transform: scale(0.5);  -moz-transform: scale(0.5);  -ms-transform: scale(0.5);  -o-transform: scale(0.5);}:root {  --trans-light: rgba(255, 255, 255, 0.66);  --trans-dark: rgba(25, 25, 25, 0.66);  --border-style: 1px solid rgb(169, 169, 169);  --backdrop-filter: none;}/* 首页文章卡片 */#recent-posts > .recent-post-item {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 25px;  border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 18px;  border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border: var(--border-style);  border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {  background: rgba(255, 255, 255, 0.75);  backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {  background: rgba(0, 0, 0, 0.7) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts > .recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page {  background: var(--trans-dark);}/* 夜间模式页脚页头遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 阅读模式 */.read-mode #aside-content .card-widget {  background: rgba(158, 204, 171, 0.5) !important;}.read-mode div#post {  background: rgba(158, 204, 171, 0.5) !important;}/* 夜间模式下的阅读模式 */[data-theme="dark"] .read-mode #aside-content .card-widget {  background: rgba(25, 25, 25, 0.78) !important;  color: #ffffff;}[data-theme="dark"] .read-mode div#post {  background: rgba(25, 25, 25, 0.78) !important;  color: #ffffff;}/* 文章页H1-H6图标样式效果 *//* 控制风车转动速度 4s那里可以自己调节快慢 */h1::before,h2::before,h3::before,h4::before,h5::before,h6::before {  -webkit-animation: ccc 4s linear infinite;  animation: ccc 4s linear infinite;}/* 控制风车转动方向 -1turn 为逆时针转动，1turn 为顺时针转动，相同数字部分记得统一修改 */@-webkit-keyframes ccc {  0% {    -webkit-transform: rotate(0deg);    transform: rotate(0deg);  }  to {    -webkit-transform: rotate(-1turn);    transform: rotate(-1turn);  }}@keyframes ccc {  0% {    -webkit-transform: rotate(0deg);    transform: rotate(0deg);  }  to {    -webkit-transform: rotate(-1turn);    transform: rotate(-1turn);  }}/* 设置风车颜色 */#content-inner.layout h1::before {  color: #ef50a8;  margin-left: -1.55rem;  font-size: 1.3rem;  margin-top: -0.23rem;}#content-inner.layout h2::before {  color: #fb7061;  margin-left: -1.35rem;  font-size: 1.1rem;  margin-top: -0.12rem;}#content-inner.layout h3::before {  color: #ffbf00;  margin-left: -1.22rem;  font-size: 0.95rem;  margin-top: -0.09rem;}#content-inner.layout h4::before {  color: #a9e000;  margin-left: -1.05rem;  font-size: 0.8rem;  margin-top: -0.09rem;}#content-inner.layout h5::before {  color: #57c850;  margin-left: -0.9rem;  font-size: 0.7rem;  margin-top: 0rem;}#content-inner.layout h6::before {  color: #5ec1e0;  margin-left: -0.9rem;  font-size: 0.66rem;  margin-top: 0rem;}/* s设置风车hover动效 6s那里可以自己调节快慢*/#content-inner.layout h1:hover,#content-inner.layout h2:hover,#content-inner.layout h3:hover,#content-inner.layout h4:hover,#content-inner.layout h5:hover,#content-inner.layout h6:hover {  color: var(--theme-color);}#content-inner.layout h1:hover::before,#content-inner.layout h2:hover::before,#content-inner.layout h3:hover::before,#content-inner.layout h4:hover::before,#content-inner.layout h5:hover::before,#content-inner.layout h6:hover::before {  color: var(--theme-color);  -webkit-animation: ccc 6s linear infinite;  animation: ccc 6s linear infinite;}.pace {  -webkit-pointer-events: none;  pointer-events: none;  -webkit-user-select: none;  -moz-user-select: none;  user-select: none;  z-index: 2000;  position: fixed;  margin: auto;  top: 4px;  left: 0;  right: 0;  height: 8px;  border-radius: 8px;  width: 7rem;  background: #eaecf2;  border: 1px #e3e8f7;  overflow: hidden}.pace-inactive .pace-progress {  opacity: 0;  transition: .3s ease-in}.pace .pace-progress {  -webkit-box-sizing: border-box;  -moz-box-sizing: border-box;  -ms-box-sizing: border-box;  -o-box-sizing: border-box;  box-sizing: border-box;  -webkit-transform: translate3d(0, 0, 0);  -moz-transform: translate3d(0, 0, 0);  -ms-transform: translate3d(0, 0, 0);  -o-transform: translate3d(0, 0, 0);  transform: translate3d(0, 0, 0);  max-width: 200px;  position: absolute;  z-index: 2000;  display: block;  top: 0;  right: 100%;  height: 100%;  width: 100%;  /* linear-gradient(to right, #3494e6, #ec6ead) */  background: linear-gradient(to right, #43cea2, #3866ca);  animation: gradient 2s ease infinite;  background-size: 200%}.pace.pace-inactive {  opacity: 0;  transition: .3s;  top: -8px}/* 背景宇宙星光  */#universe{  display: block;  position: fixed;  margin: 0;  padding: 0;  border: 0;  outline: 0;  left: 0;  top: 0;  width: 100%;  height: 100%;  pointer-events: none;  /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */  z-index: -1;}/* 夜间模式菜单栏发光字 */[data-theme="dark"] #nav .site-page,[data-theme="dark"] #nav .menus_items .menus_item .menus_item_child li a {  text-shadow: 0 0 2px var(--theme-color) !important;}/* 手机端适配 */[data-theme="dark"] #sidebar #sidebar-menus .menus_items .site-page {  text-shadow: 0 0 2px var(--theme-color) !important;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<!-- GitCalendar容器 --><div id="gitZone"></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/* 背景宇宙星光  */#universe{    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) {}    return "";};class Cursor {    constructor() {        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='1.0' fill='rgb(57, 197, 187)'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover  = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout   = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove  = e => {(this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = {x: e.clientX - 8, y: e.clientY - 8}; this.cursor.classList.remove("hidden");};        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown  = e => this.cursor.classList.add("active");        document.onmouseup    = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/light.js"/>
      <url>/js/light.js</url>
      
        <content type="html"><![CDATA[// 霓虹灯效果// 颜色数组var arr = ["#39c5bb", "#f14747", "#f1a247", "#f1ee47", "#b347f1", "#1edbff", "#ed709b", "#5636ed"];// 颜色索引var idx = 0;// 切换颜色function changeColor() {    // 仅夜间模式才启用    if (document.getElementsByTagName('html')[0].getAttribute('data-theme') ) {        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = arr[idx] + " 0 0 10px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = arr[idx] + " 0 0 5px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = arr[idx] + " 0 0 12px";            document.getElementsByClassName("author-info__description")[0].style.textShadow = arr[idx] + " 0 0 12px";        } catch {                    }        idx++;        if (idx == 8) {            idx = 0;        }    } else {        // 白天模式恢复默认        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = "#1e1e1ee0 1px 1px 1px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = "";            document.getElementsByClassName("author-info__description")[0].style.textShadow = "";        } catch {                    }    }}// 开启计时器window.onload = setInterval(changeColor, 1200);]]></content>
      
    </entry>
    
    
  
</search>
